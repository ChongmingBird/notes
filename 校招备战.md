# 【基础】

## 集合存null

- HashTable：不允许
- ConcurrentHashTable：不允许
- ConcurrentSkipListSet：不允许
- ConcurrentLinkedDeque和ConcurrentLinkedQueue：不允许
- LinkedBlockingDeque、LinkedBlockingQueue、ArrayBlockingQueue、PriorityBlockingQueue：不允许
- **List集合的.addAll方法：** 不允许传参为null，或传入的集合不支持null元素但内部有null元素存在。



- CopyOnWriteArrayList和CopyOnWriteArraySet：允许
- HashMap：允许key和value为null
- HashSet：底层使用HashMap实现，可以存null
- Vector：内部维护了Object数组，可以存null
- ArrayList：内部维护Object数组，可以存null
- LinkedList：可以存null
- LinkedHashMap：允许存null，当key为null时，hashcode为0

## ArrayList

**ArrayList是非线程安全的**

- 并发修改时会报并发修改异常

  

**扩容机制：**

- 无参构造会使用长度为0的数组
- 有参构造
  - 使用指定容量
  - Collection会使用c的大小作为数组容量
- `add(Object o)` 新元素 没有元素时，首次扩容为默认10长度数组，再次扩容为上次容量的1.5倍
  - 新容量计算：原始容量+原始容量右移一位(相当于除2)
- `addAll(Collection c)` 没有元素时，扩容为Math.max(10, 实际元素个数)；有元素时，Math.max(原始容量1.5倍，实际元素个数)



## Iterator

Fail-Fast：一旦遍历发现遍历的同时其他人来修改，则立刻抛出异常

- ArrayList是Fail-Fast：遍历的同时不能修改，否则会抛出并发修改异常

- **底层原理：**

  - `int expectedModCount = modCount;`

    迭代器持有一个创建迭代器时集合中的修改次数，每次遍历会把这个次数与集合中的修改次数做判断，如果不一致则出现并发修改异常

    ```java
    final void checkForComodification() {
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
    }
    ```

    

Fail-Safe：发现遍历的同时其他人来修改，有应对策略，比如牺牲一致性来让整个遍历运行完成

- CopyOnWriteArrayList是Fail-safe：遍历的同时允许修改，原理是读写分离，如果遍历的过程中发生了修改，遍历出的数据是未修改的数据，所以其牺牲了一致性。

- **底层原理：**

  - 迭代器读：

    ```java
    private final Object[] snapshot;
            /** Index of element to be returned by subsequent call to next.  */
            private int cursor;
    
            COWIterator(Object[] es, int initialCursor) {
                cursor = initialCursor;
                snapshot = es;
            }
    ```

    迭代器使用快照的方式保存了创建迭代器时集合中的数组，所以哪怕遍历过程中对集合进行了修改，迭代器中使用的还是原先快照保存的数组

  - 集合写：

    ```java
    public boolean add(E e) {
        synchronized (lock) {
            Object[] es = getArray();
            int len = es.length;
            es = Arrays.copyOf(es, len + 1);
            es[len] = e;
            setArray(es);
            return true;
        }
    }
    ```

    集合中添加元素时，是拷贝并扩容了原数组，再让集合中的数组的引用指向新数组

  - 从上面可以看到，fail-safe的迭代器采用了读写分离的方式，读的是原数组，写的是新数组。

## LinkedList

**共同点：**

1. ArrayList和LinkedList都是List接口的实现类，有共同的父类AbstractList和AbstractCollection；
2. 两者其中存储的数据有序，值允许重复；
3. 可以插入多个null元素；
4. 都是非线程安全的。

**不同点：**

|         差别/表          |                          ArrayList                           |                          LinkedList                          |
| :----------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|         底层实现         |                    基于数组，需要连续内存                    |                 基于双向链表，需要分散的内存                 |
| 随机访问（根据下标访问） |   实现`RandomAccess`标记接口，可以直接通过下标访问，速度快   | 需要沿着链表遍历，速度慢；因为是双向链表但是会对index做判断，根据位置选择从头遍历还是从尾遍历 |
|       根据内容查找       |       性能差不多，都是O(n)，这种场景通常会用树、哈希表       |                     性能差不多，都是O(n)                     |
|       头尾插删性能       |                          尾部性能好                          |                          头尾性能好                          |
|       中间插删性能       |                  需要移动数组元素，性能一般                  |   需要沿着链表遍历找到待修改元素位置，性能还不如ArrayList    |
|         cpu缓存          | ArrayList使用连续内存，根据局部性原理，可以一次性读入cache，可以优化性能 |      LinkedList使用分散内存，和cache机制配合得不是很好       |
|         占用内存         | ArrayList长度很大，又恰好触发了扩容机制时，会浪费数组1/3的容量；但是如果对ArrayList进行序列化，因为内部数组被transient关键字修饰，同时ArrayList重写了它的writeObject()方法，序列化时只会对数组中已使用的元素进行序列化，所以不会有多余的空间开销； | 因为链表的每个结点需要维护它的前后指针，所以肯定是LinkedList占用空间大 |

## HashMap

- **数组默认长度：16**

- **底层数据结构：**
  - jdk1.7以前：数组+链表
  - jdk1.8以后：数组+链表|红黑树

### 树化和退化

- **意义：**

  - 避免DOS攻击，防止链表超长时性能下降

- **为什么不一开始就树化**

  - 红黑树是一种不正常情况的应对策略
  - Hash表的查找更新的时间复杂度是O(1)，而红黑树查找更新的时间复杂度是O(n)，占用空间也更大，如非必要尽量使用链表

- **为什么阈值是8：**

  - jdk1.7以前，出于时间和空间成本的权衡，将加载因子设置成0.75；

    链表的树化是一种不正常的现象，会加大性能开销，是一个应当尽量避免的情况，所以我们希望树化的概率足够小。

    换而言之，当我们选中一个阈值，我们希望达到这个阈值的几率足够小。

    也就是说，我们希望知道当加入n个结点时发生k次哈希碰撞时的概率，并选取一个使得这个概率足够小的k作为阈值。

    当一个新结点加入时，发生哈希碰撞(也就是要往链表中添加结点)是一个独立随机事件，满足二项分布

    当结点很多时，二项分布近似于泊松分布，此时0.75的加载因子对应的概率参数λ≈0.5，带入泊松分布公式，可以计算出当k=8的时候，P小于6x10^-8；

    所以选取阈值是8，已经满足了我们的需求。

    ![img](https://bkimg.cdn.bcebos.com/formula/fb8ba6b970e4eb1892b70adbc0b8ef68.svg)

- **树化规则**
  - 当链表长度大于树阈值8时，先尝试扩容来减少链表长度，如果数组容量已经≥64，才会进行树化
- **退化规则：**
  - 在扩容时如果拆分树，树元素个数<=6则会退化链表
  - remove树结点时，若root、root.left、root.right、root.left.left有一个为null，也会退化为链表()、、

### 索引计算

- 首先计算对象的hashCode()

- 再次调用hashMap的hash()方法进行二次哈希

  - 二次hash()的原因：

    - **前提是数组容量为2的n次幂，此时计算元素散列到数组位置的算法是`hash & (capacity -1)`**

    - 当数组容量是2的n次幂时，其二进制数是高位的一个1和一大堆0，而length-1的二进制数是高位的一堆0和低位的一堆1

      ```java
      // 数组长度为2的8次方，其二进制数
      0000 0000 0000 0000 0000 0001 0000 0000
      // 数组长度-1的二进制数
      0000 0000 0000 0000 0000 0000 1111 1111
      // 假设一个hash值与其进行运算求索引
      	 0000 0000 0000 0000 0000 0000 1111 1111
       &   0101 0111 1110 1011 0100 1100 0101 1001
          -------------------------------------------
           0000 0000 0000 0000 0000 0000 0101 1001
      ```

      此时注意到，hash值的二进制数在进行与运算时，由于length-1的高位都是0，所以结果必然是0，换而言之hash值的高位都是无效运算，真正有效的只有低位的运算，这样会导致大量的元素被散列到相同的数组位置，造成哈希冲突的可能性大幅提高

    - HashMap中的hash()方法：`hashcode ^ (hashcode >>> 16)`，元素哈希值与高位进行异或运算，使得低位掺杂了高位特征，综合了高位数据，这样高位就不会是无效运算，从而使得哈希分布更为均匀

- 最后`hash & (capacity-1)`计算所得的容量

  - **数组容量要求2的n次方的原因：**
    - 让`hash & (length - 1)` 在结果上与取余算法一致，可以使用按位与运算代替取模，效率更高
    - 扩容时重新计算索引效率更高，`hash & oldCap == 0`的元素留在原来的位置，否则`新位置 = 旧位置 + oldCap;`

### put方法与扩容

**put流程：**

- HashMap是懒惰创建数组，只有首次使用才会创建数组
- 计算索引
- 如果桶下标没人占用，创建Node占位返回
- 如果桶下标已经有人占用
  - TreeNode走红黑树逻辑
  - Node走链表逻辑，如果超过树化阈值，先尝试扩容，如果数组长度>=64则走树化逻辑
- 返回前检查容量是否超过扩容阈值，一旦超过进行扩容，调用resize()方法，将数组长度变为原来的2倍

**1.7和1.8的区别：**

- 链表插入结点时，1.7是头插法，1.8是尾插法
- 1.7是大于等于阈值且没有空位时才扩容，1.8是大于阈值就扩容
- 1.8在扩容计算Node索引时，会优化

**加载因子为什么默认是0.75f：**

- 在空间占用与查询时间之间取得较好权衡
- 大于这个值，空间节省了，但链表就会比较长影响性能（也就是说哈希冲突多了）
- 小于这个值，冲突减少了，但扩容就会频繁，空间占用也更多

### 并发问题

HashMap使用了一个Entry数组，Entry类含有一个next指针，相当于是一个链表，所有根据key计算出具有相同存储位置的Entry类会串成一个链表。

- 扩容死链(1.7)

  1.7版本下HashMap执行头插法

  HashMap执行扩容时，会使用两个临时变量e和next迁移元素(a->b)

  线程1执行扩容时，因为头插法，迁移元素会导致链表顺序颠倒(b->a)

  但是当线程2也同时进行扩容时，线程1刚让e和next引用a和b元素，就发生线程切换，线程2执行上面线程1的操作让链表顺序颠倒(b->a->null)；这时线程切换回线程1，线程1还会继续执行迁移元素操作，因为头插法，会导致a又被加入头部并让a指向b，导致链表成环(a->b->a)。

  这样下次访问的时候，就会死循环，引发CPU使用率飙升

- 数据错乱(1.7 1.8都存在)

  两个线程同时进行put操作并且两个元素发生了哈希碰撞，那么根据HashMap的实现，他们会被添加到数组的同一个地方，那么其中有一个值被覆盖，造成了数据丢失

### Key设计

- key和value都可以为null，Map的其他实现则不然
- 作为key的对象，必须实现hashCode和equals方法，并且key的内容不能修改（不可变）
  - 重写hashcode方法：使key计算出的存储位置在hash表中有更好的分布性
  - 重写equals方法：当哈希冲突时使用equals比较是否为同一个对象
  - key内容不可修改：key内容若可以修改，可能会导致使用这个key计算出的hash值发生变化，就从hashmap中匹配不到键值对了

### String类的hashCode()设计

目标：达到较均匀的散列效果，每个字符串的hashCode足够独特

- 字符串每个字符都可以用ASCII值表示，称s[i]，其中i的范围是0~n-1

- 散列公式为：`s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]`

- 31代入公式有较好的散列特性，并且31*h可以优化为：

  `32 * h - h` => `2^5 * h - h` => `h << 5 - h`

# 【设计模式】

## 单例模式

> 单例模式：一个类只有一个实例，提供一个访问该类对象实例的全局访问方法
>
> - 单例模式常见五种实现方式
> - jdk中体现单例模式的地方

### 实现方式

#### 饿汉式

类初始化就会创建唯一实例

- 构造器私有
- 静态成员变量持有自身的唯一实例
- 使用公共静态方法`getInstance()`提供自身的唯一实例

```java
public class Singleton1 implements Serializable {
    private Singleton1() {
        // 防止单例模式被破坏
        if (INSTANCE != null) {
            throw new RuntimeException("单例对象不能重复创建");
        }
        System.out.println("private Singleton1()");
    }
    
	// 持有自身实例的静态变量
    private static final Singleton1 INSTANCE = new Singleton1();

    public static Singleton1 getInstance() {
        return INSTANCE;
    }

    public static void otherMethod() {
        System.out.println("otherMethod()");
    }

    public Object readResolve() {
        return INSTANCE;
    }
    
}
```

- 破坏单例模式的例子：

  - 反射破坏

    ```java
    private static void reflection(Class<?> clazz) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
        	// 反射获取构造器并设置可访问，从而创建对象实例
            Constructor<?> constructor = clazz.getDeclaredConstructor();
            constructor.setAccessible(true);
            System.out.println("反射创建实例:" + constructor.newInstance());
        }
    ```

    **预防方法：** 构造器中判断是否已存在实例，已存在则不允许调用构造器

    ```java
    private Singleton1() {
            // 防止单例模式被破坏
            if (INSTANCE != null) {
                throw new RuntimeException("单例对象不能重复创建");
            }
            System.out.println("private Singleton1()");
    }
    ```

  - 如果单例对象实现了serializable接口，字节数组反序列化生成新对象，会被破坏（深拷贝了一个新的实例）

    ```java
    private static void serializable(Object instance) throws IOException, ClassNotFoundException {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(instance);
        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));
        System.out.println("反序列化创建实例:" + ois.readObject());
    }
    ```

    **预防方法：** 单例类中实现readResolve()方法

    ```java
    // 重写这个方法，反序列化时直接放回这个实例，而不走字节数组反序列化
    public Object readResolve() {
            return INSTANCE;
    }
    ```

  - UnSafe类破坏，没法预防

    ```java
    private static void unsafe(Class<?> clazz) throws InstantiationException {
        Object o = UnsafeUtils.getUnsafe().allocateInstance(clazz);
        System.out.println("Unsafe 创建实例:" + o);
    }
    ```

#### 枚举饿汉式

**枚举类：**

- 枚举值是`public static final `静态常量，且不能主动创建
- 枚举类构造方法默认私有
- 枚举法天然能防反射、反序列化破坏单例

```java
public enum Singleton2 {    
    INSTANCE;
    private Singleton2() {
        System.out.println("private Singleton2()");
    }
    public static Singleton2 getInstance() {
        return INSTANCE;
    }
}
```

**自定枚举：**

```java
public enum Planet {
    MERCURY (3.303e+23, 2.4397e6),
    VENUS   (4.869e+24, 6.0518e6),
    EARTH   (5.976e+24, 6.37814e6),
    MARS    (6.421e+23, 3.3972e6),
    JUPITER (1.9e+27,   7.1492e7),
    SATURN  (5.688e+26, 6.0268e7),
    URANUS  (8.686e+25, 2.5559e7),
    NEPTUNE (1.024e+26, 2.4746e7);

    private final double mass;   // in kilograms
    private final double radius; // in meters
    
    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
    }
    private double mass() { return mass; }
    private double radius() { return radius; }
}
```



#### 懒汉式

第一次调用`getInstance()`时才创建实例

**多线程环境下，需要考虑线程安全问题** 

所以需要对`getInstance()`加锁

但是只有首次创建单例对象才需要互斥保护，实际上该代码每次调用都会同步，影响性能，所以有如下双检锁懒汉

```java
public class Singleton3 implements Serializable {
    private Singleton3() {
        System.out.println("private Singleton3()");
    }
	
    // 初始为null
    private static Singleton3 INSTANCE = null;
	
    // 对静态方法加synchronized关键字，相当于对类加锁
    public static synchronized Singleton3 getInstance() {
        // 第一次调用getInstance时才创建
        if (INSTANCE == null) {
            INSTANCE = new Singleton3();
        }
        return INSTANCE;
    }

    public static void otherMethod() {
        System.out.println("otherMethod()");
    }

}
```

#### 双检锁懒汉式

加锁之前先判断，如果已经创建了实例直接返回，否则才创建实例

- 为什么使用volatile修饰INSTANCE变量
  - 多线程情况下，首个`if(INSTANCE == null)`没有被互斥保护，两个线程都可以访问
  - `INSTANCE = new Singleton4()`不是原子操作，分成三步：创建对象分配内存空间、调用构造、给静态变量赋值。后两步可能被指令重排序，变成先赋值再调用构造
  - 线程1可能已经为对象分配内存空间并赋值给INSTANCE，但构造方法还没执行，很多成员变量还没初始化
  - 此时线程2发现INSTANCE已经不为null，就直接返回INSTANCE
  - 但INSTANCE对象没有被完整构造，发生了错误
  - 添加volatile关键字后，会插入内存屏障禁止特定类型处理器对INSTANCE变量操作的指令重排序，避免上述不完整构造错误
- 为什么两次检查`if(INSTANCE == null)`
  - 假设线程1和2都进入if块，线程1竞争到了锁并创建了对象
  - 如果没有第二次if判断，线程1解锁时已经创建了对象，但线程2获取锁后还会重复创建对象

```java
public class Singleton4 implements Serializable {
    private Singleton4() {
        System.out.println("private Singleton4()");
    }
	// volatile关键字：解决共享变量的可见性和有序性
    // 这里使用volatile保证有序性
    private static volatile Singleton4 INSTANCE = null; 

    public static Singleton4 getInstance() {
        if (INSTANCE == null) {
            // 假设线程1和2都进入if块，线程1竞争到了锁并创建了对象
            // 如果没有第二次if判断，线程1解锁时已经创建了对象，但线程2获取锁后还会重复创建对象
            synchronized (Singleton4.class) {
                if (INSTANCE == null) {
                    INSTANCE = new Singleton4();
                }
            }
        }
        return INSTANCE;
    }
}
```

#### 内部类懒汉式

饿汉式类初始化时就给静态变量赋值，这个操作是放在静态代码块中执行。

静态代码块的执行处于类生命周期中的初始化阶段，由虚拟机保证其原子性且安全执行，所以不用考虑并发问题

```java
public class Singleton5 implements Serializable {
    
    private Singleton5() {
        System.out.println("private Singleton5()");
    }
	// 内部持有一个内部类
    private static class Holder {
        // static修饰变量，相当于用static代码块包裹，虚拟机保证原子性且安全执行
        static Singleton5 INSTANCE = new Singleton5();
    }
	// 执行getInstance()，内部类使用时才初始化，才会创建实例
    public static Singleton5 getInstance() {
        return Holder.INSTANCE;
    }

    public static void otherMethod() {
        System.out.println("otherMethod()");
    }
}
```

### JDK中单例的体现

- 饿汉式：
  - Runtime类：`System.exit()`使用了`Runtime.getRuntime().exit(status);`
- 双检索懒汉式：
  - Console类：System类中有一个Console类，是系统控制台的类
- 内部类懒汉式：
  - Collections类中的EmptyIterator内部类
- 枚举饿汉式：
  - Collections类中的Comparators有一个内部枚举类NaturalOrderComparator

# 【并发】

## 线程状态

### Java的线程状态

![image-20210831090722658](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20210831090722658.png)

|      状态       |                             解释                             |                             说明                             |
| :-------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|      `NEW`      |           新建一个线程对象，还没有调用start()方法            |               new一个线程实例，线程还没有start               |
|   `RUNNABLE`    |     `READY`:就绪态<br />`RUNNING`:运行态<br />`阻塞I/O`      |                    等待被调度或正在运行中                    |
|    `BLOCKED`    |                       表示线程阻塞于锁                       |     线程阻塞在进入synchronized修饰的方法或代码块时的状态     |
|    `WAITING`    | 进行该状态的线程需要等待其他线程做出一些特定动作（通知或中断） | 条件不满足，调用wait()，让出CPU，等待被显示的唤醒，被唤醒后进入BLOCKED状态，重新获取锁 |
| `TIMED_WAITING` |         不同于waiting，它可以在指定的时间后自行返回          | 超时等待，或者调用sleep(long)、wail(long)，让出CPU，时间到了自动唤醒，进入BLOCKED状态，重新获取锁（sleep唤醒进入RUNNABLE） |
|  `TERMINATED`   |                     表示显示已经执行完毕                     |                                                              |

**RUNNABLE:**

- READY:

  - 有资格运行，但还没有被调度
  - 调用线程的start方法进入此状态
  - 当线程sleep方法结束，其他线程join结束，等待用户输入完毕，某个线程拿到对象锁，这些线程都会进入此状态
  - 当前线程时间片用完了，调用线程的yield方法，进入此状态
  - 锁池里的线程拿到对象锁后，进入此状态

- RUNNING：

  - 线程调度程序选中该线程进行运行

- 操作系统线程阻塞等待I/O：

  JVM并不关系操作系统线程的实际状态，在JVM看来，等待CPU使用权（操作系统的RUNNABLE态）与阻塞I/O（操作系统WAITING）没有区别，所有都归入RUNNABLE状态

**BLOCKED：**

- 由synchronized锁导致进入该状态
- WAITING、TIMED_WAITING状态下唤醒也可能进入该状态

**WAITING：**

- 各情况下进入该状态，线程不会占用CPU，线程会让出锁，等待被其他线程唤醒，然后会进入BLOCKED状态，重新竞争锁。

**TIMED_WAITING:**

- 各个情况下进入该状态，线程不会占用CPU，时间到了自动唤醒
- sleep进入该状态，线程不会释放锁，进入RUNNABLE状态
- 各情况下进入该状态，线程会让出锁，等待被其他线程唤醒，然后会进入BLOCKED状态，重新竞争锁。

**TERMINATED：**

- 线程 run()方法完成时，或者主线程main()方法结束时，就认为它终止了。

- 这个线程对象也许是活的，但是已经不是一个单独执行的线程了，线程一旦终止了就不能复生，在一个终止的线程上调用 start()方法，会抛出 `java.lang.IllegalThreadStateException` 异常

### OS的线程状态

- 新建态(NEW)： 
- 就绪态(RUNABLE)：
- 运行态(RUNNING)：
- 阻塞态(WAITING)：
- 终结态(TERMINATED)

## 线程池

### 线程池核心参数

![image-20210831093204388](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20210831093204388.png)

submit提交任务，offer进任务队列(workQueue)，核心线程（可以为0）需要保持在线程池中，救急线程不需要保持在线程池中

1. `corePoolSize` 核心线程数目 - 池中会保留的最多线程数
2. `maximumPoolSize` 最大线程数目 - 核心线程+救急线程的最大数目
3. `keepAliveTime` 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放
4. `unit` 时间单位 - 救急线程的生存时间单位，如秒、毫秒等
5. `workQueue` - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务
6. `threadFactory` 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等
7. `handler` 拒绝策略 - 当所有线程都在繁忙，workQueue也放满时，会触发拒绝策略，拒接提交任务
   1. 抛异常 `java.util.concurrent.ThreadPoolExecutor.AbortPolicy`
   2. 由调用者执行任务 `java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy`
   3. 丢弃任务 `java.util.concurrent.ThreadPoolExecutor.DiscardPolicy`
   4. 丢弃最早排队任务 `java.util.concurrent.ThreadPoolExecutor.`

## wait和sleep

**共同点：** 让当前线程暂时放弃CPU的使用权，进入BLOCK阻塞状态

​				wait(long)和sleep(long)都使线程进入TIMED_WAITING状态

​				wait()使线程进入WAITING状态

**不同点：**

- 方法归属不同：
  - sleep是Thread的静态方法
  - wait是Object的成员方法，每个对象都有
- 醒来时机不同：
  - sleep(long)和wait(long)都会在等待相应毫秒后醒来
  - wait可以被notify唤醒，wait()如果不唤醒就会一直等待下去
  - sleep和wait都可以被打断唤醒，让阻塞的线程抛出被打断异常并被唤醒
- 锁特性不同
  - wait方法的调用必须先获取wait对象的锁，sleep无此限制
  - wait方法执行后会释放对象锁，允许其他线程获取此锁，因此唤醒后进入BLOCK状态（需要重新竞争锁）
  - sleep如果在synchronize代码块中执行，不会释放对象锁，因此醒来后进入RUNNABLE的READY状态（不需要重新竞争锁）

## lock和synchronized

- 语法层面
  - synchronized是关键字，源码在jvm中，使用c++实现
  - Lock是接口，源码由jdk提供，用java语言实现
  - 使用synchronized时，退出同步代码块锁会自动释放，而使用lock时，需要手动调用unlock方法释放锁

- 功能层面

  - 二者均属于悲观锁，都具备基本的互斥、同步、锁重入功能
    - 悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据
    - 互斥：一个公共资源同一时刻只能被一个线程使用，多个线程不能同时使用公共资源
    - 同步：两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行
    - 锁重入：同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响
  - Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、非公平锁、可打断、可超时、多条件变量
    - 公平锁：多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁
  - Lock有适合不同场景的实现，如ReentrantLock，ReentrantReadWriteLock

- 性能层面

  - 在没有竞争时，synchronized做了很多优化，如偏向锁、轻量级锁，性能不赖
  - 在竞争激烈时，Lock的实现通常会提供更好的性能

  ## volatile

  **原子性：**

  - 起因：多线程下，不同线程的指令发生了交错导致了共享变量的读写混乱
  - 解决：用悲观锁或乐观锁解决，volatile并不能解决原子性

  **可见性：**

  - 起因：由于编译器优化、或缓存优化、或 CPU 指令重排序优化导致的对共享变量所做的修改另外的线程看不到
  - 解决：用volatile修饰变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见

  **有序性：**

  - 起因：由于编译器优化、或缓存优化、或 CPU 指令重排序优化导致指令的实际执行顺序与编写顺序不一致
  - 解决：用volatile修饰共享变脸会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果

  **注意：**

  - **volatile变量写:** 加的屏障是阻止上方其他写操作越过屏障排到volatile变量写之下
  - **volatile变量读:** 加的屏障是阻止下方其他读操作越过屏障排到volatile变量读之上
  - volatile读写加入的屏障只能防止同一线程内的指令重排

  

## 悲观锁和乐观锁

**悲观锁的代表是synchronized和Lock锁：**

- 核心思想：线程只有占有了锁，才能去操作共享变量，每次只有一个线程占锁成功。获取锁失败的线程，都得停下来等待
- 线程从运行到阻塞、再从阻塞到唤醒，涉及线程上下文切换，如果频繁发生，影响性能
- 实际上，线程在获取synchronized和Lock锁时，如果锁已经被占用，都会做几次重试操作，减少阻塞的机会

**乐观锁的代表是AtomicInteger，使用cas来保证原子性：**

- 核心思想：无需加锁，每次只有一个线程能成功修改共享变量，其他失败的线程不需要停止，不断重试直至成功
- 由于线程一直运行，不需要阻塞，因此不涉及线程上下文切换
- 需要多核cpu支持，且线程数不应超过cpu核数

## Hashtable和ConcurrentHashMap

**共同点：** 都是线程安全的Map集合，且key和value都不能为空

**不同点：**

- Hashtable并发度低，整个Hashtable对应一把锁，同一时刻，只能有一个线程操作它
- 1.8以前ConcurrentHashMap使用了Segment+数组+链表的结构，每个Segment对应一把锁，如果多个线程访问不同的Segment，则不会冲突
- 1.8开始ConcurrentHashMap将数组的每个头结点作为锁，如果多个线程访问的头结点不同，则不会冲突

**ConcurrentHashMap1.7：**

- **数据结构：**

   `Segment(大数组) + HashEntry(小数组) + 链表`，每个 Segment 对应一把锁，如果多个线程访问不同的 Segment，则不会冲突

- **并发度：**

  Segment数组大小即并发度，决定了同一时刻最多能有多少个线程并发访问。Segment数组不能扩容，意味着并发度在ConcurrentHashMap创建时就固定了

- **索引计算：**

  - 假设大数组长度2^m，key在大数组内的索引是key的二次hash值的高m位
  - 假设小数组长度是2^n，key在小数组内的索引是key的二次hash值的低n位

- **扩容：**

  每个小数组的扩容相对独立，小数组在超过扩容因子时会触发扩容，每次扩容翻倍

**ConcurrentHashMap1.8：**

- **数据结构：**

  `Node 数组 + 链表或红黑树`，数组的每个头结点作为锁，如果多个线程访问的头节点不同，则不会冲突。

  首次生成头节点时如果发生竞争，利用 cas 而非 syncronized，进一步提升性能

- **并发度：**

  Node 数组有多大，并发度就有多大，与 1.7 不同，Node 数组可以扩容

- **扩容：**

  - 扩容条件：Node数组满3/4时就会扩容
  - 扩容单位：旧数组迁移到新数组，以链表为单位从后向前，将旧链表迁移到新数组，迁移完成的将旧数组头结点替换为ForwardingNode
  - 扩容时并发get：
    - 根据是否为ForwardingNode来决定是在新数组查找还是在旧数组查找，不会阻塞
    - 如果链表长度超过1，则需要对结点进行复制(创建了新结点，因为害怕结点的next指针指向错误)
    - 如果链表最后几个元素扩容后索引不变，则结点无需复制（因为next指针不需要修改，不会指向错误）
  - 扩容时并发put：
    - 正在迁移的链表会被加锁，如果put的线程与扩容线程操作的链表是同一个，put线程会阻塞
    - 如果put的线程操作的链表还未迁移，即头结点不是ForwardingNode，则可以并发执行
    - 如果put的线程操作的链表已经迁移完成，即头结点是ForwardingNode，则可以协助扩容

## ThreadLocal

**作用：**

- ThreadLocal可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题
- ThreadLoacl相比局部变量，生命周期不局限于某个方法，ThreadLocal实现了线程内的资源共享
- 【核心思想】：共享变量在每个线程都有一个副本，每个线程操作的都是自己的副本，对另外的线程没有影响。

**原理：**

每个线程内有一个ThreadLocalMap类型的成员变量，里面包含一个静态的内部类Entry，持有一个Entry数组，Entry<Threadlocal, value>用来存储资源对象

![img](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterv2-ce5b8a32cd1245c7c8af5fc15ffcc39f_r.jpg)

- 调用set方法，就是以ThreadLocal自己作为key，资源对象作为value，放入当前线程的ThreadLocalMap集合中
- 调用get方法，就是以ThreadLocal自己作为key，到当前线程中查找关联的资源值
- 调用remove方法，就是一ThreadLocal自己作为key，移除当前线程关联的资源值

**ThreadLocalMap的特点：**

- key的hash值统一分配

- 初始容量16.，扩容因子2/3，扩容后容量翻倍

- key索引冲突后采用开放寻址法解决冲突

  开放寻址法：当前单元哈希冲突，遍历表找到一个不冲突的单元存放

  拉链法：在发生冲突的单元上形成链表

**弱引用key：**

ThreadLocalMap中的key被设计为弱引用

- Thread可能需要长时间运行（比如线程池中的线程），如果key不再使用，需要在内存不足（GC）时释放其占用的内存
  - 强引用：内存不足不会被垃圾回收
  - 弱引用：内存不足会被垃圾回收，且只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。
- 但GC仅是让key的内存释放，后续还要根据key是否为null来进一步释放值的内存，释放时机有：
  1. 获取key发现null key
  2. set key时，会使用启发式扫描，清楚临近的null key，启发次数与元素个数、是否发现null key有关
  3. remove时，同时释放<key, value>，因为一般使用ThreadLocal时都会把它当做静态变量(强引用)，GC无法回收，所以推荐使用这种方法

