# 【算法分析】

![image-20221013204933521](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20221013204933521.png)

**O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)**

# 【排序】

## 临时

```java
/**
 * 排序前：{4,5,6,3,2,1}
 * 排序后：{1,2,3,4,5,6}
 */
@Test
public void selectionTest() {
    // 包装类实现了Comparable接口
    Integer[] arr = {4,5,6,3,2,1};
    System.out.println(Arrays.toString(arr));
}

/**
 * 对数组a中的元素进行排序
 * @param a
 */
public static void sort(Comparable[] a){}

/**
 * 比较v元素是否大于w元素
 * @param v
 * @param w
 * @return
 */
private static boolean greater(Comparable v, Comparable w){
    return v.compareTo(w)>0;
}

/**
 * 交换数组元素i和j的位置
 * @param a
 * @param i
 * @param j
 */
private static void swap(Comparable[] a, int i, int j){
    Comparable temp = a[i];
    a[i] = a[j];
    a[j] = temp;
}
```



## Comparable接口

> Java提供了一个接口Comparable用来定义排序规则

```java
class Student implements Comparable<Student> {
    
    String username;
    int age;
    
    // 定义比较规则
    @Override
    public int compareTo(Student o) {
        return this.age - o.age;
    }
    @Override
    public String toString() {
        return "Student{" +
                "username='" + username + '\'' +
                ", age=" + age +
                '}';
    }
}
```

## 冒泡排序

**排序原理：**

1. 比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。
2. 对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大值。

![image-20221013210507201](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20221013210507201.png)

**时间复杂度：** O(n^2)

**API设计：**

![image-20221013210243598](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20221013210243598.png)

**代码实现：**

```java
public class Bubble {
    /**
     * 排序前：{4,5,6,3,2,1}
     * 排序后：{1,2,3,4,5,6}
     */
    @Test
    public void bubbleTest() {
        Integer[] arr = {4,5,6,3,2,1};
        Bubble.sort(arr);
        System.out.println(Arrays.toString(arr));
    }
    
    /**
     * 对数组a中的元素进行冒泡排序
     * @param a
     */
    public static void sort(Comparable[] a) {
        // i决定有多少个元素参与冒泡，每次循环排好一个最大值
        for (int i=a.length-1; i>0; i--) {
            // 有i个元素参与冒泡。就要比较i次
            for (int j=0; j<i; j++) {
                if (greater(a[j], a[j+1])) {
                    swap(a, j, j+1);
                }
            }
        }
    }

    /**
     * 比较v元素是否大于w元素
     * @param v
     * @param w
     * @return
     */
    private static boolean greater(Comparable v, Comparable w) {
        return v.compareTo(w)>0;
    }

    /**
     * 交换数组元素i和j的位置
     * @param a
     * @param i
     * @param j
     */
    private static void swap(Comparable[] a, int i, int j) {
        Comparable temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

## 选择排序

**排序原理：**

1.  每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引
2. 交换第一个索引处和最小值所在的索引处的值

![image-20221013212334425](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20221013212334425.png)

**时间复杂度：** O(n^2)

**API设计：**

![image-20221013212439185](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20221013212439185.png)

**代码实现：**

```java
public class Selection {
    /**
     * 排序前：{4,6,8,7,9,2,10,1}
     * 排序后：{1,2,4,5,7,8,9,10}
     */
    @Test
    public void selectionTest() {
        // 包装类实现了Comparable接口
        Integer[] arr = {4,6,8,7,9,2,10,1};
        Selection.sort(arr);
        System.out.println(Arrays.toString(arr));
    }

    /**
     * 对数组a中的元素进行排序
     * @param a
     */
    public static void sort(Comparable[] a){
        // 每次排好一个最小值，只需要排length-1次
        for (int i=0; i<a.length-1; i++) {
            // 定义一个变量，记录最小元素所在的索引，默认为参与排序的第一个元素的位置
            int minIndex = i;
            // 找出最小值所在的索引
            for (int j=i+1; j<a.length; j++) {
                if (greater(a[minIndex], a[j])) {
                    minIndex = j;
                }
            }
            // 交换索引minIndex与索引i的位置
            swap(a, i, minIndex);
        }
    }

    /**
     * 比较v元素是否大于w元素
     * @param v
     * @param w
     * @return
     */
    private static boolean greater(Comparable v, Comparable w){
        return v.compareTo(w)>0;
    }

    /**
     * 交换数组元素i和j的位置
     * @param a
     * @param i
     * @param j
     */
    private static void swap(Comparable[] a, int i, int j){
        Comparable temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

## 插入排序

**排序原理：**

1. 把所有的元素分为两组，已经排序的和未排序的；
2. 找到未排序的组中的第一个元素，向已经排序的组中进行插入；
3. 倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待插入元素放到这个位置，其他的元素向后移动一位；

![image-20221013215115150](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20221013215115150.png)

**时间复杂度：** O(n^2)

**API设计：**

![image-20221013215453439](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20221013215453439.png)

**代码实现：**

```java
public class Insertion {
    /**
     * 排序前：{4,3,2,10,12,1,5,6}
     * 排序后：{1,2,3,4,5,6,10,12}
     */
    @Test
    public void insertTest() {
        // 包装类实现了Comparable接口
        Integer[] arr = {4,3,2,10,12,1,5,6};
        Insertion.sort(arr);
        System.out.println(Arrays.toString(arr));
    }

    /**
     * 对数组a中的元素进行排序
     * @param a
     */
    public static void sort(Comparable[] a){
        // 默认a[0]为排好的一组元素
        for (int i=1; i<a.length; i++) {
            for (int j=i; j>0; j--) {
                // 如果a[j-1]比a[j]大，则交换位置;否则本次插入成功
                if (greater(a[j-1], a[j])) {
                    swap(a, j-1, j);
                } else {
                    break;
                }
            }
        }
    }

    /**
     * 比较v元素是否大于w元素
     * @param v
     * @param w
     * @return
     */
    private static boolean greater(Comparable v, Comparable w){
        return v.compareTo(w)>0;
    }

    /**
     * 交换数组元素i和j的位置
     * @param a
     * @param i
     * @param j
     */
    private static void swap(Comparable[] a, int i, int j){
        Comparable temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

