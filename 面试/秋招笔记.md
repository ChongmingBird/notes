# 【Java集合】

## HashMap

- 默认长度16

- 最大长度为2的30次幂

- 默认加载因子0.75

- 树化临界值`数组长度>=64 && 链表长度>=7`

- 退化临界值6

- HashMap采用Node数组，Node对象实现了Entry接口，存放`<key,value>`

- jdk1.8的hashmap初始化(new)的时候**只赋值了默认的长度16和加载因子**(有参构造可以修改这两个值，其中长度会自动换算成2的整次幂向上取整)，

  **不会创建node数组，node数组是在第一次put的时候懒加载创建的**

### 底层数据结构

> HashMap的底层数据结构是数组和链表
>
> - JDK1.8以前：数组+链表
> - JDK1.8以后：数组+链表+红黑树

- HashMap使用数组来存储元素，每个数组位置被称为桶（bucket）。每个桶可以存储一个或多个键值对。

- 当有多个键值对被映射到一个桶上，即发生hash冲突时，HashMap会采用拉链法生成链表。
- 当链表长度满足树化条件（数组长度≥64，链表长度＞8）时，链表就会转化为红黑树（JDK1.8）

通过数组+链表+红黑树的数据结构，HashMap能够实现高效的键值对存储和检索，并且具有平均时间复杂度为 O(1) 的特性

### 为什么采用红黑树

- HashMap在链表长度过长时采用红黑树的**主要目的**是提高查找和插入操作的性能。因为当链表长度较长时，查找和插入操作的时间复杂度会达到O(n)
- 红黑树作为一种自平衡的二叉查找树，具有较好的平衡性质，用红黑树代替链表可以降低至O(log n)的复杂度，尤其是在处理大量数据时可以显著提高性能
  - 和平衡二叉树（AVL树）相比，红黑树放弃严格的完全平衡，保证每次插入最多只需要三次旋转就能达到平衡，实现更简单，插入和删除的开销更低更可控
  - 和B+树相比，红黑树不用存储索引信息和指针，避免额外的空间开销
  - 和跳表相比，跳表额外的指针实现层级结构构建和维护，红黑树的实现更加标准化和直接，插入删除的时间开销和空间开销更有优势

- 需要注意的是，**HashMap仅在链表长度较长时才会进行红黑树的转换，以避免引入额外的开销**

  > 在HashMap的源码里，作者有这样一段注释，大致意思是
  >
  > 一个较好的hash函数会让数据散列均匀而很少树化
  >
  > 理想情况下，随机hash码中桶内结点的频率遵循泊松分布
  >
  > 当加载因子为0.75，泊松分布以λ=0.5入参。作者计算了不同k时的概率p
  >
  > 当k=8时，p=0.00000006 （6*10^-8）
  >
  > ****
  >
  > **退化阈值为什么是6**
  >
  > 如果退化阈值也是8的话，当哈希碰撞发生次数在8左右时，会出现链表和红黑树的反复转化，非常浪费性能

### put/get流程

**get流程：**

- 首先，HashMap会根据`key`的哈希值，通过`hash()`方法计算出该键对应的哈希桶（bucket）的索引位置。

- 在索引位置上，HashMap会检查该桶的首结点，

  - **如果结点为空：**则返回null，表示没有找到对应的值。

  - **如果结点不为空，则遍历桶内元素：**

    - **对应单结点：**如果首结点的key与目标key匹配，直接返回结点

    - **对应树结点：**如果结点不匹配，会检查是否为树结点来选择树遍历方式（instance of 关键字）

    - **对应链表结点：**上述检查都通过，则遍历链表中的下一个结点，重复本轮步骤

- 如果遍历完全还没有找到结点，则返回null



**put流程：**

- 首先，HashMap会根据`key`的哈希值，通过`hash()`方法计算出该键对应的哈希桶（bucket）的索引位置。
- 在索引位置上，HashMap会检查该桶的首结点。
  - **如果结点为空：**将该键值对作为新结点放入桶中
  - **如果结点不为空，则遍历桶内元素：**
    - **对应单结点：**如果首结点的key与目标匹配，则更新结点
    - **对应树结点：**如果首结点是树结点，则通过树的插入方法进行插入操作
    - **对应链表结点：**如果上述检查没有通过，则遍历链表中的下一个结点，重复本轮步骤，直到找到匹配的key来执行更新操作

- 如果遍历完整链表依然没有匹配的键值对，则将该键值对作为一个新的结点插入到桶中
- 如果链表长度超出了阈值（数组长度≥64，链表长度>8），则会进行树化，以提高查找和插入的效率

### 线程不安全

HashMap是线程不安全的集合，在多线程环境下会有并发问题

**HashMap的线程不安全主要体现在：**

- 在 jdk1.7 中，在多线程环境下，扩容时会造成死循环或数据丢失（链表头插法导致）

  - **死循环场景：**

    ```txt
    假设当前桶中元素 A->B->C->null，扩容后ABC仍然发生哈希冲突
    扩容时元素迁移顺序是A、B、C，采用头插法，理想条件下执行结果是C->B->A->null
    当前两个线程T1、T2并发执行扩容操作，且T1初始化状态后挂起
    此时T1、T2的初始状态都是e=A和next=B
    当线程T2执行扩容完毕，链表变成C->B->A->NULL
    T1苏醒，继续执行扩容，根据它线程栈内的e和next，它会修改A.next=B，导致链表变成C->B->A->B，形成了死循环
    ```

  - **数据丢失场景：**

    ```
    
    ```
    

- 在 jdk1.8 中，在多线程环境下，会发生数据覆盖的情况。



**如何让HashMap变得线程安全：**

- 使用`Collections.synchronizedMap()`方法：

  可以通过`Collections.synchronizedMap()`方法将HashMap包装成一个线程安全的Map。例如：

  ```java
  Map<String, Integer> synchronizedMap 
      = Collections.synchronizedMap(new HashMap<>());
  ```

  这会返回一个线程安全的Map对象，它会对所有的操作进行同步处理（为所有操作添加synchronized锁），从而保证线程安全性。

- 使用`ConcurrentHashMap`：

  `ConcurrentHashMap`是Java提供的线程安全的哈希表实现，它使用了一种不同的锁机制，称为分段锁（Segment Locking），可以同时支持多个线程的并发读操作。例如：

  ```java
  ConcurrentHashMap<String, Integer> concurrentHashMap 
      = new ConcurrentHashMap<>();
  ```

- 使用其他线程安全的数据结构：

  如`Hashtable`、`CopyOnWriteHashMap`等。

### 为什么长度是2的整次幂

当n为2次幂时，会满足一个公式：

`(n - 1) & hash = hash % n`

就可以用位运算代替取余运算，计算更加高效。

**解释：**

hashmap默认长度16（二进制10000），16-1=15（二进制01111）

hash & 15，最终结果就是只保留了hash中的低4位数据。

这个值就在数组长度范围内，可以作为散列到的数组下标，

这一结果和以数组长度取余的结果是相同的。

**这就解释了为什么hashmap数组长度要求是2的整次幂，因为2的整次幂-1的二进制是高位全0低位全1，进行&运算就可以舍弃高位保留低位，起到取余的效果**

### 哈希值计算

HashMap的哈希值计算采用了两次哈希运算：

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

1. 计算key的hash值，调用key自身的`hashcode()`方法

2. 将key的hash值h执行`h^(h>>>16)`

   即h的高位不变，低位部分变成低位+高位的异或值

**原因：**

因为hashmap长度采用2的n次幂，在计算散列位置的时候，将`hash % n`运算优化为了 `hash & (n-1)`

而hashmap的初始长度为16，也就是初始时的运算为：

`hash & (此处省略28个0)1111`

**在hashmap长度不大的时候，hash高位的数据在运算后全变成0，全部丢失，没有参与到散列位置的计算。**

**容易造成元素散列位置的聚集，大大增加了hash冲突的可能性**

对hash值的低位部分采用高位+低位的异或运算，将高位信息掺入低位信息进行扰动，可以分散数据的散列位置，减少哈希冲突，提高性能。

### String的hashcode方法

String常作为key，String要设计成不可变类的好处之一，只需要计算一次hashcode

**String的hashCode()方法：**

```java
public int hashCode() {
    /* private int hash; // Default to 0 */
    int h = hash;
    if (h == 0 && value.length > 0) {
        char val[] = value;
        /* 核心：h = 31 * h + val[i]; */
        for (int i = 0; i < value.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;
    }
    return h;
}
```

`h = 31 * h + val[i]`：hash值的计算将hash每次乘31再加上char数组元素的ascii码

**个人理解：**

`31 * h = (h * 32) - h = (h << 5) - h` 编译器会自动优化成位运算 

### 扩容机制

- hashmap是懒加载，只有在第一次put的时候才会创建数组
- 默认扩容大小为原来的2倍

****

**JDK 1.7以前扩容，条件：**

- 当前存储数量大于等于阈值
- 发生hash碰撞

**特点：**先判断是否扩容，再添加，采用头插法

**缺点：**头插法会使链表发生反转，多线程环境下可能会死循环

**扩容后对table的调整：**

容量变成原来的2倍，所有元素下标都重新计算：

`e.hash & (newCap - 1)`

注意`e.hash`，e为结点，e.hash其实是key的hash值：`h ^ (h >>> 16)`

****

**JDK 1.8以后扩容，条件：**

- 当前存储的数量大于等于阈值
- 当某个链表长度>=8，但是数组存储的结点数size() < 64时（即不满足树化条件的时）

**特点：**先添加，再判断是否需要扩容，采用尾插法

**缺点：**多线程下会有数据覆盖的问题

**扩容后对table的调整：**

table容量变为2倍，所有元素下标重新计算：

`e.hash & (newCap - 1)`

注意`e.hash`，e为结点，e.hash其实是key的hash值：`h ^ (h >>> 16)`

### 扩容因子0.75

- 加载因子过高，哈希碰撞概率太大，查询效率降低，因为遍历链表要O(n)
- 加载因子太低，频繁扩容，降低空间利用率，增加额外开销

加载因子是0.75是基于空间利用率和查找效率的折中取值

### null问题

HashMap可以存放一个键是null，多个值为null的对象。

HashMap在桶下标0的位置存放null键

HashTable和ConcorrentHashMap均不支持键或值为null的对象，因为并发环境下需要避免null的二义性：

**null二义性**

当`get(key)`获取的value为`null`时，有两种可能

- 该key的value为null
- 该key不存在

在HashMap中，可以使用`containsKey()`方法检查key是否存在，再使用`get(key)`方法获取。

但是在并发容器中，该操作非原子操作，可能存在`containsKey()`检查通过后key被其他线程删除的情况，导致null出现二义性。故并发容器不支持存储null

## ArrayList/LinkedList

> ArrayList多用于访问频繁的场景
>
> LiknedList多用于修改频繁的场景

- **内部实现：**

  - ArrayList：基于数组实现的动态数组，它通过数组的连续内存空间来存储元素
  - LinkedList：基于双向链表实现的，每个元素都包含了对前一个和后一个元素的引用（同时也是双端队列）

- **访问速度：**

  - ArrayList的随机访问速度更快，可以通过索引快速访问元素。因为基于数组，它可以通过偏移量直接计算出元素的内存地址。

  - LinkedList的访问速度较慢，因为它需要从头或尾开始遍历链表才能访问到特定位置的元素。

  - **上述前提是基于元素位置访问。**

    **如果是基于元素访问，**因为ArrayList数组采用连续内存空间，可以一次性读入内存，访问速度应当也比LinkedList要快

- **内存消耗：**

  ArrayList在存储相同数量的元素时通常比LinkedList占用更少的内存空间。

  因为LinkedList需要额外的指针来维护链表结构，而ArrayList只需要数组本身。

- **插入和删除操作：**

  - 从集合头部插入/删除元素时，ArrayList慢很多，因为涉及数组元素的迁移；
  - 从集合中间位置插入/删除元素时，ArrayList可能会快一些，因为LinkedList需要遍历链表；
  - 从集合尾部插入/删除元素时，ArrayList快一点，因为LinkedList涉及修改结点的引用。

## ArrayList扩容

- 空参创建集合，底层创建默认长度为0的数组

- 添加元素时，如果数组已满，调用`grow()`方法

- 添加第一个元素时（此时`minCapacity`为1），底层会创建一个新的长度为10的数组

- 当数组长度存满后，再添加元素，扩容数组

  扩容数组会计算扩容的容量:

  ```java
  int newCapacity = ArraysSupport.newLength(
  	oldCapacity, // 旧容量
      minCapacity - oldCapacity, // 最小需要扩容的容量
      oldCapacity >> 1 // 默认扩容容量为旧容量的一半
  );
  ```

  - 当数组存满后，会创建一个新数组，数组长度是原来的1.5倍
  - 如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准

## fail-fast：迭代器并发修改异常

> fail-fast 快速失败，失败就会抛出异常

**fail-fast** 机制是**Java集合**(Collection)中的一种**错误机制**。 在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的结构进行了修改（增加、删除），则会抛出**Concurrent Modification Exception**（并发修改异常）。

**原理：**

- `ArrayList`内部持有变量`int modCount`，每次修改都会使其自增，类似版本号
- `Iterator`创建时`int expectedModCount = modCount`，设置期望值为当前ArrayList的版本号，相当于快照
- 迭代器每次迭代，都会检查自己的`expectedModCount`和ArrayList里的`modCount`是否相等，若不相等则抛出`Concurrent Modification Exception`（并发修改异常）

****

如何避免并发修改异常

- 不可以在foreach循环里对元素进行remove/add操作；
- remove可以使用迭代器的remove方法，此方法会更新`expectedModCount`为当前的`modCount`；
- 如果并发操作，需要对Iterator对象加锁；

## fail-safe：CopyOnWriteArrayList

> fail-safe：用安全失败机制的集合容器,在遍历时不是直接在集合内容上访问的,而是先copy原有集合内容,在拷贝的集合上进行遍历
>
> 相当于快照

**CopyOnWriteArrayList：读写分离思想**，实现线程安全，适合用于写多读少的情况

- **写时复制**

  当往容器添加元素时：

  1. 复制一个新容器
  2. 在新容器里添加元素
  3. 将旧容器的引用指向新容器

  **注意：**

  写的时候会添加`ReentrantLock`可重入互斥锁，采用FIFO等待队列管理获取该锁的线程，从而保证写的并发执行；

- **并发读取**

  因为采用写时复制机制，

  1. 当并发读取时，迭代器在创建会采用快照机制获取当前容器的引用（也就是旧容器）；
  2. 后续的读取都是在旧容器上进行的；
  3. 就算此时发生了并发写，集合的容器被替换成了新容器，也不影响迭代器里对旧容器的读取

## HashSet/HashTable

- HashSet 的内部采用了HashMap作为数据存储，HashSet其实就是在操作HashMap的key

- HashTable底层实现和HashMap一致，但是使用了Synchronized锁，支持多线程，但性能低

## ConcurrentHashMap

> **ConcurrentHashMap是JUC下线程安全的HashMap容器**

**1.7版本：** 使用的分段锁

采用Segment数组+HashEntry数组的形式，大数组包含小数组

每个Segment类似于HashMap的结构，HashEntry数组（即桶）+链表

Segment继承了`ReetrantLock`，每次加锁锁住一个Segment，也就是锁住一个小HashEntry数组（一个小的hashmap）

![Java 7 ConcurrentHashMap 存储结构](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterjava7_concurrenthashmap.png)

****

**1.8版本**

1.8版本ConcurrentHashMap采用锁粒度更小的Node数组+链表/红黑树的模式，更像1.8版本的HashMap；加锁时直接锁在Node上

![Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterjava8_concurrenthashmap.png)

**写入数据时：**

- 桶内为空采用CAS方式自旋写入
- 桶内不为空，采用synchronized锁方式添加到链表/红黑树

**因为Java在1.8版本优化了synchronized关键字：锁升级机制（偏向锁->轻量级锁(自旋锁)->重量级锁），所以性能方面还是有保障的**

## LinkedHashMap

底层结构：LinkedHashMap内部使用了一个哈希表和一个双向链表来实现。

哈希表用于快速查找元素，而双向链表用于维护元素的顺序。

每个节点都包含了对前一个和后一个节点的引用，因此它可以保持元素的插入顺序或访问顺序。

应用场景：LinkedHashMap适用于需要保持元素插入顺序或访问顺序的场景。以下是一些常见的应用场景：

1. 记录访问顺序：通过使用LinkedHashMap，可以记录元素的访问顺序。这对于实现缓存、最近访问记录等功能非常有用。
2. LRU缓存：基于LinkedHashMap实现的LRU（Least Recently Used）缓存，可以根据访问顺序来淘汰最近最少使用的元素。通过重写`removeEldestEntry()`方法，可以控制缓存的大小。
3. 迭代顺序：LinkedHashMap提供了两种迭代顺序：插入顺序和访问顺序。可以根据需要选择合适的顺序进行迭代操作。
4. 保持元素顺序：如果需要保持元素的插入顺序或自定义的顺序，LinkedHashMap可以很方便地满足这个需求。它提供了一种有序的集合实现。

# 【Java基础】

## Object常用方法

1. `toString()`: 返回对象的字符串表示。默认实现返回对象的类名和哈希码的十六进制表示，可以根据需要进行重写，以返回更有意义的字符串。
2. `equals(Object obj)`: 比较两个对象是否相等。默认实现比较对象的引用是否相同，可以根据需要进行重写，以实现自定义的相等逻辑。
3. `hashCode()`: 返回对象的哈希码。默认实现返回对象的内存地址转换而来的哈希码，通常与`equals()`方法一起使用，需要满足“相等的对象必须具有相等的哈希码”原则。
4. `getClass()`: 返回对象的运行时类。返回的是Class类的实例，可以获取对象所属的类信息。
5. `clone()`: 创建并返回对象的副本。实现深拷贝时需要重写该方法，并在方法中创建对象的拷贝。
6. `finalize()`: 在对象被垃圾回收器回收之前调用。可以重写该方法来执行对象资源释放或清理的操作。
7. `notify()`和`notifyAll()`: 用于实现线程间的通信机制。`notify()`方法唤醒一个等待中的线程，`notifyAll()`方法唤醒所有等待中的线程。
8. `wait()`: 使当前线程进入等待状态，直到其他线程调用对象的`notify()`或`notifyAll()`方法唤醒该线程。

## 面向对象/面向过程

**面向过程：**

面向过程是一种以事件为中心的编程思想，编程的时候把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数。

****

**面向对象：**

面向对象是一种以“对象”为中心的编程思想，把要解决的问题分解成各个对象，**建立对象的目的不是为了完成一个步骤，而是为了描述某个对象在整个解决问题的步骤中的属性和行为**

## 面向对象三大特性

- **封装：**

  把数据和操作数据的方法封装起来，对数据的访问只能通过已定义的接口

- **继承：**

  继承是从已有类得到继承信息创建新类的过程；提供继承信息的是父类/超类/基类，继承继承信息的是子类

- **多态：**同一类型，表现出多种不同行为

  - 编译时多态（方法重载）
  - 运行时多态（方法重写）

****

## 权限修饰符

| 权限/修饰符  | `public` | `protected` | `default` | `private` |
| :----------: | :------: | :---------: | :-------: | :-------: |
|   同一个类   |   YES    |     YES     |    YES    |    YES    |
|   同一个包   |   YES    |     YES     |    YES    |    NO     |
|  不同包子类  |   YES    |     YES     |    NO     |    NO     |
| 不同包非子类 |   YES    |     NO      |    NO     |    NO     |

- `public`：所有类都可以访问
- `protected`：同一个包下所有类，及其（不同包下）子类可以访问
- `default`：同一个包下可以访问
- `private`：只有同一个类下可以访问

## 重载和重写的区别

- **重载（Overload）**

  方法之间的多态性

  - 函数名相同
  - 参数列表可以不同
  - 返回类型可以不同
  - 访问修饰符可以不同
  - 抛出异常可以不同

- **重写（Override）**

  父类与子类之间的多态性，是子类对父类函数的重新实现

  - 函数名、参数列表、返回值必须与父类一样

  - 子类访问修饰符必须大于父类访问修饰

    （public>protected>default>private）

  - 子类抛出异常不能比父类更宽泛

## 是否可以重写private/static方法

Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。

Java 中也不可以覆盖 private 的方法，因为 private 修饰的变量和方法只能在当前类中使用， 如果是其他的类继承当前类是不能访问到 private 变量或方法的，当然也不能覆盖。

> 静态的方法可以被继承，但是不能重写。
>
> 如果父类和子类中存在同样名称和参数的静态方法，那么该子类的方法会把原来继承过来的父类的方法隐藏，而不是重写。
>
> 通俗的讲就是父类的方法和子类的方法是两个没有关系的方法，具体调用哪一个方法是看是哪个对象的引用；这种父子类方法也不在存在多态的性质。

## 父类无参构造的作用

空构造方法：无参数且不做事

**Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中的无参构造**。

如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误。

## 创建对象的方式

1. new 对象

2. Class类的newInstance方法，该方法基于反射，调用无参构造器创建对象

   `Class.forName.newInstance()`

3. 使用`clone()`方法

4. 反序列化

## 抽象类和接口的区别

1. 抽象类中可以定义**构造函数**；接口不能定义构造函数
2. 抽象类中可以有**抽象方法和具体方法**；接口中只能有抽象方法（public abstract）
3. 抽象类的**成员权限**不能是private(抽象类中的抽象方法就是为了重写，所以不能是private)；接口只能是public
4. 抽象类中可以有静态方法；接口中不可以有静态方法（JDK 8之后可以）

**JDK 8 中的改变：**

1. **接口中**允许包含**default修饰的带具体实现的方法**，即默认方法
2. 抽象类中可以包含**静态方法**；**接口在JDK 8 之后可以包含**，但只能通过接口调用，且不能包含静态代码块；

## 静态变量和实例变量的区别

**静态变量：** static修饰，属于类变量，存放在方法区；无论创建多少个实例对象，静态变量在内存中有且仅有一个拷贝；静态变量可以实现让多个对象共享内存

**实例变量：**属于某个实例，和对象一起存放在堆中（JVM经JIT优化后可能会栈上分配）需要创建对象

## short=1系列错误

```java
short s1 = 1;
s1 = s1 + 1;
```

s1+1在运算时自动提升表达式的类型为int，将int类型值赋值给shrot类型变量，s1会发生类型转换错误

```java
short s1 = 1;
s1 += 1;
```

`+=`是 Java 语言规定的运算符，Java编译器会对其进行特殊处理，可以正确编译

## Error和Excetion

Error和Excetion都是Throwable的子类

- Error：程序无法处理的系统错误，比如JVM错误，栈溢出等
- Exception：程序可以处理的异常，可以被捕获，被处理
  - RuntimeException：运行时异常，程序应当承担的责任
  - 非RuntimeException：检查时异常，编译器应当承担的责任

![image-20230421100138647](https://chongming-images.oss-cn-hangzhou.aliyuncs.com/images-masterimage-20230421100138647.png)



## Hash冲突解决

- **开放地址法（闭散列）：**

  一旦发生冲突，就寻找下一个空的散列地址；

  ```
  Hi = (H(key) + di) MOD m，其中i=1,2,…,k(k<=m-1)
  H(key)为哈希函数，m为哈希表表长，di为增量序列，i为已发生冲突的次数。
  ```

  - 线性探测法：当前冲突位置为起点，步长为1循环查找
  - 平方(二次）探测法：当前冲突位置为起点，步长di=1^2，-1^2，2^2，-2^2，……
  - 伪随机探测法：当前冲突位置为起点，随机步长循环查找

- **再哈希法**

  构造多个不同的哈希函数，直到不冲突为止

  ```
  Hi=RH1（key） i=1，2，…，k
  ```

- **拉链法（开散列）：**

  将所有哈希地址相同的都链接在同一个链表中 ，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况，hashmap就是基于此方法解决冲突的。

- **建立公共溢出区：**

  将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。

****

**拉链法对比开放地址法的优点**

- 拉链法处理冲突简单，且无堆积现象；即非同义词绝不会发生冲突，因此平均查找长度较短
- 拉链法中各链表上的结点空间是动态申请的，适合造表前无法确定表长的情况
- 开放定址法为减少冲突，要求装载因子α较小（频繁扩容），故当结点规模较大时会浪费很多空间。
- 在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可

## Integer

1. int 是 Java 的八种基本数据类型之一，而 Integer 是 Java 为 int 类型提供的封装类；
2. int 型变量的默认值是 0，Integer 变量的默认值是 null，这一点说明 Integer 可以区分出未赋值和值为 0 的区分；
3. Integer 变量必须实例化后才可以使用，而 int 不需要。

**Integer 和 int 的比较延伸**：

1. `Integer == int` Integer会自动拆箱，实际上是两个int类型变量比较
2. `Integer.equals(Integer)`：Integer重写了equals方法，会先比较类型再比较值（所以String和Integer比较一定是false）
3. `Integer == Integer`：比较的是地址值

## 包装类型的hashcode方法

- `Integer`

  hashcode为Integer的值

- `String`

  ```java
  hashcode = 31 * h + val[i];
  // 31 * h == (h << 5) - h
  ```

- `Long`

  ```java
  hashcode = value ^ (value>>>32);
  // 前32位和后32位进行异或运算
  // 最后结果就是高位不变，低位是高位和低位的异或结果
  ```

- `Double`

  同Long

- `Character`

  hashcode为字符对应的ASCII值

- `Boolean`

  ```java
  value ? 1231 : 1237;
  ```

## switch语句

**在 switch(expr 1) 中，expr1 只能是一个整数表达式或者枚举常量。**

而整数表达式可以是 int 基本数据类型或者 Integer 包装类型。由于，byte、short、char 都可以**隐式转换为 int**，所以，这些类型以及这些类型的包装类型也都是可以的。

而 long 和 String 类型都不符合 switch 的语法规定，并且不能被隐式的转换为 int 类型，所以，它们不能作用于 switch 语句中。

**不过，需要注意的是在 JDK 7 版本之后 switch 就可以作用在 String 上了。（且实际上是通过hashcode实现）**

## static关键字

（1）静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份；

（2）静态方法：静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字；

（3）静态语句块：静态语句块在类初始化时运行一次；

（4）静态内部类：非静态内部类依赖于外部类的实例，而静态内部类不需要。静态内部类不能访问外部类的非静态的变量和方法；

（5）初始化顺序：静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序

**存在继承关系时的初始化顺序：**

- 父类（静态变量、静态代码块）
- 子类（静态变量、静态代码块）
- 父类（实例变量、普通代码块）
- 父类（构造函数）
- 子类（实例变量、普通代码块）
- 子类（构造函数）

## final、finally、finalize

`final`：用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、被其修饰的类不可继承；

`finally`：异常处理语句结构的一部分，表示总是执行；

`finallize()`：Object类的一个方法，在垃圾回收时会调用被回收对象的finalize()

## hashcode()和equals()

是否需要重写equals()方法：是否需要根据自己的规则判断两个对象是否相等

是否需要重写hashcode()方法：在需要使用散列表的场景中，需要确保相同的对象具有相同的hash值

**为什么说修改equals方法就必须修改hashcode方法？**

- 该命题不绝对，只有在需要使用散列表的场景才必须修改hashcode方法

- 散列表调用hashcode()方法获取对象的hash值，来确定散列位置。

  散列表要满足条件：**相同对象散列到相同位置**

  所以就要确保当前规则下相同对象具有相同的hash值，如果重写了equasls()方法**（即修改了判定对象相同的规则）**，就一定要修改hashcode()**（确保当前规则下的相同对象还具有相同hash值）**

## &和&&

Java 中 && 和 & 都是表示与的逻辑运算符，都表示逻辑运输符 and，当两边的表达式都为 true 的时候，整个运算结果才为 true，否则为 false。

`&&`：有短路功能，当第一个表达式的值为 false 的时候，则不再计算第二个表达式；

`&`：不管第一个表达式结果是否为 true，第二个都会执行。

除此之外，& 还可以用作位运算符，& 表示按位与操作。

## 参数传递

Java 的参数是以**值传递**的形式传入方法中，而不是引用传递。

当传递方法参数类型为基本数据类型（数字以及布尔值）时，一个方法是不可能修改一个基本数据类型的参数。

当传递方法参数类型为引用数据类型时，实际上传入的是**引用的拷贝**，所以：

- **在方法中修改引用的对象的值**，因为两个引用指向同一对象，所以**成功**
- **在方法中修改引用指向的对象**，仅仅只修改了方法中的引用的指向；对方法外的引用**无影响**

## 两个二进制数的异或结果

两个二进制数异或结果是这两个二进制数差的绝对值。表达式如下：a^b = |a-b|

因为异或运算按位运算，1-0=0；0-1=1，相当于按位绝对值相减，再按位相加

## 如何实现对象的克隆

（1）实现 Cloneable 接口并重写 Object 类中的 clone() 方法，clone()方法默认是浅克隆；

（2）实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深克隆。

## 深克隆和浅克隆的区别

1. **浅克隆：**

   拷贝对象和原始对象的引用类型引用同一个对象。浅克隆只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅克隆。

2. **深克隆：**

   拷贝对象和原始对象的引用类型引用不同对象。深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse() 和 JSON.stringify()，但是此方法无法复制函数类型）。

## Java序列化

对象序列化是一个用于将对象状态转换为字节流的过程，可以将其保存到磁盘文件中或通过网络发送到任何其他程序。从字节流创建对象的相反的过程称为反序列化。

创建的字节流是与平台无关的，在一个平台上序列化的对象可以在不同的平台上反序列化。

序列化是为了解决在对象流进行读写操作时所引发的问题。

需要注意的是，要实现序列化，对象必须实现`Serializable`接口，该接口没有任何方法，只是一个标记接口。

**什么时候需要序列化：**

## 泛型如何工作/类型擦除

**泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。**

例如：List\<String> 在运行时仅用一个 List 来表示。这样做的目的，是确保能和 Java 5 之前的版本开发二进制类库进行兼容。

**类型擦除：**

泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。

在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 < T > 则会被转译成普通的 Object 类型，如果指定了上限如 < T extends String > 则类型参数就被**替换成类型上限**。

## 通配符

**限定通配符：** 泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误

- `< ? extends T >`：传入类型是T或T的子类
- `< ? super T >`：传入类型是T或T的父类

**非限定通配符**

- `< ? >`：接收任意类型

## 反射

每个类都有一个 Class 对象，包含了与类有关的信息。

当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。

类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。

也可以使用 Class.forName(“com.mysql.jdbc.Driver”) 这种方式来控制类的加载，该方法会返回一个 Class 对象。

反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。

Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：

（1）Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；

（2）Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；

（3）Constructor ：可以用 Constructor 创建新的对象。

应用举例：工厂模式，使用反射机制，根据全限定类名获得某个类的 Class 实例。

## 反射的优缺点

**优点：**

运行期类型的判断，class.forName() 动态加载类，提高代码的灵活度；

**缺点：**

尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。

（**1）性能开销 ：**

**反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。**因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。

**（2）安全限制 ：**

使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。

**（3）内部暴露：**

由于反射允许代码执行一些在正常情况下不被允许的操作（比如：访问私有的属性和方法，比如破坏单例模式），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。

## String为何要设置成不可变

1. **实现字符串常量池：**String类型引用指向常量池中的字符串常量，如果String可变，就无法让多个String引用常量池中的同一个字符串了

2. **允许String对象缓存hashcode：**String不可变，hashcode只需要计算一次，具有唯一性，就可以缓存在对象里；考虑到String类型常用于散列表，这样做提高性能

3. **String类型常被多个Java类作为参数，不可变可以保证安全性**

   比如网络地址的url、文件的地址、反射机制需要的参数等，String的改变可能造成很多安全隐患

4. **不可变对象的String天然线程安全**

## String/Builder/Buffer

- **String：**

  实现了CharSequence接口

  用于字符串操作，属于不可变类；

  【补充：String 不是基本数据类型，是引用类型，底层用 char 数组实现的，但char数组使用了private final static修饰，不可被外界访问(private)，引用的数组不可更改(final)，不可被继承(static)，从而实现String的不可变】

- **StringBuffer：**

  也用于字符串操作，不同之处是 StringBuffer 属于可变类，**对方法加了同步锁，线程安全**

- **StringBuilder：**

  与 StringBuffer 类似，都是字符串缓冲区，但**线程不安全，效率更高**；

**StringBuilder和StringBuffer：**继承了AbstractStringBuilder类，实现了CharSequence接口和Appendable接口

****

**执行效率**：StringBuilder > StringBuffer > String

****

当用String类型来对字符串进行修改时，首先创建一个StringBuilder，其次调用 StringBuilder的append() 方法，最后调用StringBuilder的toString() 方法把结果返回。

**toString()方法产生的字符串不会进入常量池**

所以`"a"+"b"`的`"ab"`字符串不会加入常量池

## 字符串常量池

`String str = "i"` ：添加到字符串常量池（如果存在会直接使用常量池中的常量）

`String str = new String("i")` ：分配到堆内存

## String常用方法

indexOf()：返回指定字符的索引。

charAt()：返回指定索引处的字符。

replace()：字符串替换。

trim()：去除字符串两端空白。

split()：分割字符串，返回一个分割后的字符串数组。

getBytes()：返回字符串的 byte 类型数组。

length()：返回字符串长度。

toLowerCase()：将字符串转成小写字母。

toUpperCase()：将字符串转成大写字符。

substring()：截取字符串。

equals()：字符串比较。

## IO流分类

**功能分：**

- 输入流（input）
- 输出流（output）

**类型分：**

- **字节流**（in/out put stream）

  字节流按照字节为单位(8bit)输入输出数据

  - **字节缓冲流**【BufferedInput(Output)Stream】

    缓冲流内部维护字节数组，一次性读取多个字节，减少IO次数

- **字符流**（reader/writer）

  字符流按照字符为单位(16bit)输入输出顺序

  - **字符缓冲流**【BufferedReader(Writer)】

    缓冲流内部维护字符数组，一次性读取多个字符，减少IO次数

![img](https://image.iamshuaidi.com/picture/640.jpeg)

![img](https://image.iamshuaidi.com/picture/image-20210602135829398.png)