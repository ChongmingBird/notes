# 【计算机网络】

## 分层模型

> OIS分层模型
>
> 1. 应用层
>
> 1. 应用层
> 2. 表示层
> 3. 会话层
> 4. 传输层
> 5. 网络层
> 6. 数据链路层
> 7. 物理层

**TCP/IP模型：**

- **应用层**

  包含各种应用程序和协议，提供各种网络服务

- **传输层**

  提供数据传输服务，并包括TCP和UDP等协议

- **网络层**

  负责路由选择、分组转发和寻址，还包括IP协议

- **网络接口层**

  处理物理媒介和数据链路管理

## 从输入URL到页面展示到底发生了什么

1. **检查缓存：**

   浏览器已缓存的资源会被返回；没有则进入下一步网络请求

2. **DNS解析：**

   浏览器解析url域名，向本地DNS缓存或DNS服务器发送请求，递归查找域名对应的IP地址

3. **获取MAC地址**

   当浏览器得到IP地址以后，数据传输还需要知道目的主机MAC地址。

   - 传输层：TCP协议指定源端口号和目的端口号

   - 网路层：将本机地址作为源地址，获取的IP地址作为目的地址

   - **数据链路层：**

     需要通信双方的MAC地址，先查询本地ARP缓存
     通过**将IP地址与本机的子网掩码AND运算（结果保留网络号，主机号置0）**，

     - 如果是相同网段判断为子网，通过ARP协议获取目的主机的MAC地址
     - 如果不在同一个子网内，请求转发给网关，由网关代为转发，此时目的主机的MAC地址应为网关的地址。

3. **建立TCP连接（三次握手），发起HTTP请求：**

   浏览器与服务器建立TCP连接后，会向目标服务器发送HTTP请求；

   该请求包括要访问页面的URL、请求方法、请求头和其他相关信息

4. **服务器处理请求：**

   服务器收到请求信息，处理请求并生成响应数据返回给浏览器

5. **浏览器解析响应头**

   - `301`、`302`状态码会重定向到新地址
   - 字节流数据会将请求提交给下载管理器
   - HTML类型会解析页面相关资源，浏览器渲染页面

## 三次握手过程

> **为什么三次握手？**
>
> 三次握手可以确保通信双方正确接收和发送数据
>
> **第一次握手：**服务端确认己方接收正常，对方发送正常
>
> **第二次握手：**客户端确认己方发送接收都正常、对方发送接收也正常
>
> **第三次握手：**服务端确认己方发送正常，对方接收正常
>
> 可见，三次握手即可让客户端服务端都确认双方能正确接收和发送数据
>
> **如果两次握手：服务端无法确认自己的发送能力和对方的接收能力**
>
> **如果四次握手：增加网络系统的负担，造成资源的浪费**

1. 客户端向服务端发送`SYN`报文，初始化序列号`ISN:seq=x`

   **客户端进入`SYN_SENDS`状态**

   这一阶段，服务端接收到报文后，确认自己接收正常，对方发送正常

2. 服务端接收客户端报文，发送携带`ACK:x+1`标志位(且ack number为x+1)的`SYN`报文，初始化序列号`ISN:seq=y`

   **服务端进入`SYN_RECV`状态**

   这一阶段，客户端确认自己发送正常、接收正常；服务端发送正常、接收正常

3. 客户端接收服务端报文，发送携带`ACK:y+1`标志位的`SYN`报文，此次握手可以携带数据。

   **客户端、服务端进入`ESTABLISHED`状态，完成三次握手**

   此次握手，服务端确认对方接收正常，自己发送正常

> - `SYN`（synchronize）
> - `ISN:seq=x`(Initial Sequence Number)
> - `ACK`(Acknowledge)，`x+1`是ack number

## 四次挥手过程

> **为什么是四次挥手？**
>
> TCP是全双工通信，可以双向传输数据；要完全关闭连接，双方都需要向对方发出连接释放的通知并回复对方的通知。
>
> 两次握手可以释放一端到另一端的单向连接，完全释放连接需要四次挥手。
>
> **此外第二次挥手和第三次挥手可以合并**，即服务端可以等待自己数据传输完成后，同时发送释放连接的通知和确认对方的通知

1. 客户端发送`FIN`报文给服务端，指定序列号`seq=x`，进入`FIN_WAIT_1`状态

   此次挥手，客户端告知服务端自己不再发送数据，仍能接收数据

2. 服务端收到`FIN`报文后，指定序列号为`seq=y`，回复`ACK Number = x+1`的`ACK`报文，，进入`CLOSE_WAIT`状态，

   客户端接收到`ACK`报文后，进入`FIN_WAIT_2`状态

   此次挥手，服务端告知客户端不再接收数据，仍需发送数据

3. 当服务端也无数据发送后，会发送`seq=y+1`的`FIN`报文，进入`LAST_ACK`状态，等待对方确认

   此次挥手，服务端告知客户端自己不再发送数据

4. 客户端接收到确认后，回复`ACK Number = y+2`的`ACK`报文，进入`TIME_WAIT`状态，在等待`2MSL`（2个最长报文段寿命）后没有收到回复，才关闭连接

   服务端收到`ACK`报文后，进入`CLOSE`状态

> MSL：Maximum Segment Lifetime
>
> 报文最大生存时间

## TCP和UDP的概念、特点，区别和对应的使用场景

|     区别     |                             TCP                              |                             UDP                              |
| :----------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   **概念**   | 一种面向连接的、可靠的协议；确保数据在发送和接收之间按序到达，无损坏与重复 | 一种无连接的、不可靠的协议；提供最小的数据传输服务，只负责数据单向传输 |
|   **特点**   | 可靠性、有序性、面向连接，提供流量控制与拥塞控制，面向字节流 |             无连接、不可靠、简单、速度，面向报文             |
| **使用场景** | 需要可靠数据传输的应用，如网页浏览、电子邮件、SSH远程登录等  |        要求通信速度高的场景，如DNS查询、流媒体直播等         |

## HTTP请求常见的状态码和字段

**HTTP常见字段：**

|      字段      |                         功能                         |
| :------------: | :--------------------------------------------------: |
|      Host      |              指定服务器的主机名和端口号              |
|  Content-Type  |             指定请求或响应实体的媒体类型             |
| Content-Length |             指定请求或响应实体的字节长度             |
|     Accept     |            指定客户端可接收的响应媒体类型            |
|   User-Agent   | 包含发起请求的用户代理（通常是浏览器或应用程序）信息 |

**常见状态码：**

| 状态码 |                             功能                             |
| :----: | :----------------------------------------------------------: |
|  1xx   |                 提示信息，协议处理的中间状态                 |
|  2xx   |                           请求成功                           |
|  3xx   |                          请求重定向                          |
|  4xx   | 请求错误，通常是客户端请求问题<br />401 未授权<br />403 服务器拒绝请求<br />404 服务器找不到请求的资源 |
|  5xx   |                  服务端错误，需要检查服务端                  |

## 常见的请求方式，GET与POST请求的区别

**请求方式：**

| 请求方式 |                             作用                             |
| :------: | :----------------------------------------------------------: |
|   GET    |     请求获取指定资源。该请求不应对服务器状态产生任何影响     |
|   POST   | 用于向服务器提交数据，通常用于创建新资源或对现有资源进行修改 |
|   PUT    |       用于向服务器上传指定的资源，通常用于更新现有资源       |
|  DELETE  |                  用于请求服务器删除指定资源                  |

**Get请求和Post请求的区别：**

|     区别     |                   GET                    |                    POST                    |
| :----------: | :--------------------------------------: | :----------------------------------------: |
|     作用     |                 请求资源                 |                  提交数据                  |
| 数据传输方式 |               附加在URL中                |               包含在请求体中               |
|    安全性    |         敏感信息可能在URL中暴露          |                  相对安全                  |
| 数据大小限制 |              受URL长度限制               |            通常不受严格大小限制            |
|    幂等性    | 幂等的，多次相同请求不会对服务器造成影响 | 非幂等，多次相同请求会对服务器造成不同结果 |

## HTTP1.0与HTTP1.1的区别

|   区别   |                           HTTP1.0                            |                           HTTP1.1                            |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 持久连接 |         默认非持久连接，每个请求/响应都需要单独连接          | 持久连接，允许多个请求和响应共享一个TCP连接，减少连接和关闭开销 |
|  管道化  | 不支持管道化，即客户端必须等待上一个请求的响应才能发送下一个请求 | 支持管道化，允许客户端在不等待响应的情况下发送多个请求，提高了并发性能 |
|  主机头  |      不包含Host头字段，因此每个HTTP请求需要独立的IP地址      |          引入Host头字段，允许多个域名共享一个IP地址          |
| 错误处理 |                          简单状态码                          |                      新增24个错误状态码                      |
| 缓存控制 |       使用`If-Modified-Since/Expires`作为缓存判断标准        |         引入更多缓存策略如`Entity Tag/If-None-Match`         |

## 什么是强缓存和协商缓存

- **强缓存：**

  浏览器判断请求的目标资源是否有效命中强缓存，如果命中，则可以直接从内存中读取目标资源，无需与服务器做任何通讯

- **协商缓存：**

  当资源过期或需要验证时，浏览器将发送一个包含`If-Modified-Since`（基于Last-Modified）或`If-None-Match`（基于ETag）的条件请求头字段到服务器。

  服务器使用这些条件来判断资源是否发生了变化。如果资源没有变化，服务器会返回一个`304 Not Modified`的响应，告诉浏览器可以使用本地缓存的资源，否则服务器将返回新的资源并带上新的`Last-Modified`或`ETag`值。

## HTTP和HTTPS的区别

|    区别    |              HTTP              |                            HTTPS                             |
| :--------: | :----------------------------: | :----------------------------------------------------------: |
|   安全性   |        不安全，明文传输        |                  安全，使用TLS/SSL加密技术                   |
|  协议表示  |           `http://`            |                          `https://`                          |
|  默认端口  |               80               |                             443                              |
| 证书和加密 |      不涉及，通信内容明文      | 使用数字证书验证服务器身份，并使用TLS/SSL协议对数据进行加密和解密 |
|  响应速度  |            相对较快            |                           相对较慢                           |
|  使用场景  | 非敏感信息传输，如浏览普通网页 |       保护敏感信息的网站和应用，如登录凭据、信用卡号码       |

## Https的工作原理

1. **客户端发起连接请求**

   客户端向服务端发送请求报文，请求与服务端建立连接

2. **服务端提供证书**

   服务器接收到连接请求后，会将其数字证书发送给客户端，数字证书中包含服务器公钥

   数字证书通常由受信任的第三方机构签发，用于验证服务器的身份

3. **客户端验证证书**

   客户端验证服务器发送的证书，检查是否有效、是否过期以及签发机构是否可信任

   验证成功，客户端继续连接；否则显示警告或终止连接

4. **客户端生成随机密钥**

   客户端生成一个随机对称密钥key，用于加密和解密数据。这个密钥通常称为“对话密钥”

5. **客户端使用服务器的公钥加密会话密钥**

   客户端使用服务器的公钥（从服务器证书中提取）来加密生成的随机密钥key

   这个加密的会话密钥key会被发送到服务器，但只有服务器拥有相应的私钥才能解密它

6. **服务器使用私钥解密会话密钥**

   服务器使用自己的私钥加密客户端发送的加密会话密钥，得到key

7. **建立安全通信**

   一旦服务器解密了会话密钥，客户端和服务器都拥有了相同的会话密钥key，用于之后的通信

   所有的数据传输都将使用这个共享的会话密钥来加密和解密，保护通信内容的完整性

## DNS是什么，以及查询过程

> DNS（Domain Name System）域名管理系统，是互联网上用于将人类可读的域名转换为计算机可理解的IP地址的分布式命名系统。
>
> 主要功能是将域名映射到与之相关联的IP地址，从而使用户可以使用便于记忆的域名来访问互联网上的各种服务和资源

1. **用户发起域名查询请求**

   当用户在Web浏览器中输入一个域名（如www.google.com）时，操作系统会发起一个DNS查询请求，以查找与该域名相关联的IP地址。

2. **本地缓存查询询**

   首先，操作系统会检查本地DNS缓存，看是否已经存储了该域名的解析结果。

   本地缓存包含了浏览器缓存和计算机本地Host文件中的缓存

3. **本地DNS服务器查询**

   如果本地缓存中没有找到域名解析结果，操作系统会向本地DNS服务器发送查询请求。

   通常，这个本地DNS服务器由互联网服务提供商（ISP）分配给用户，也可以是企业内部的DNS服务器。

4. **本地DNS服务器器启动递归查询流程**

   如果本地DNS服务器在自己的缓存中没有找到域名解析结果，它将启动一个递归查询过程。

5. **根域名服务器查询**

   向根域名服务器发送查询请求。

   根域名服务器不负责解析域名，但它能告诉本地DNS解析器应该向哪个顶级域的DNS服务器继续查询（.com/.net/.org）

6. **顶级域名服务器查询**

   本地DNS服务器接着向顶级域名服务器发送查询请求，请求找到目标域名的权威域名服务器（通常是注册该域名的域名注册商）。

7. **权威域名服务器查询**

   本地DNS服务器最后向权威DNS服务器发起查询请求。

   权威DNS服务器是负责存储特定域名和IP地址映射的服务器。当权威DNS服务器收到查询请求时，它会查找请求的域名对应的IP地址并返回给本地DNS服务器

8. **本地DNS服务器响应**

   本地DNS服务器将目标域名的解析结果存储到缓存中，并将该结果返回给操作系统

9. **操作系统响应，返回域名解析结果给应用程序**

10. **应用程序访问目标服务器**

## TCP连接如何确保可靠性

1. **序列号和确认应答**

   TCP将数据分成一些列的数据段并为数据段分配序列号，接收方接收数据后会发送确认消息，未被确认的数据段会被重传。

2. **有序交付**

   接收方会按照序列号顺序重新组装数据，确保数据的有序交付

3. **超时重传机制**

   - 如果发送方在一定时间内没有收到确认消息，会认为数据丢失并重新发送数据段
   - 接收方会检查序列号，以避免接收重复数据

4. **流量控制**

   - TCP使用流量控制机制来确保发送方不会发送太多数据，从而导致接收方无法处理。这个机制通过滑动窗口实现
   - 发送方通过接收方的窗口大小来调整发送速率，以确保流量控制的可靠性

5. **拥塞控制**

   - TCP使用拥塞控制机制来防止网络拥塞。当网络拥塞时，TCP会减小发送速率，以减轻网络负载。
   - 拥塞控制通过检测丢失的数据包和网络延迟来实现，以适应当前网络状况。

6. **校验和**

   - TCP使用校验和来检测数据段的错误
   - TCP不提供纠正机制，而是依靠重传来纠正丢失或损坏的数据

## 拥塞控制如何实现

1. **拥塞窗口**
   - 拥塞控制的核心概念是拥塞窗口，表示可以发送到网络的未确认数据量。
   - 发送方会根据网络的拥塞程度来动态调整拥塞窗口的大小
   - 拥塞窗口以字节为单位，它限制了发送方可以发送的数据量
2. **慢启动**
   - TCP连接刚开始时，发送方会初始化拥塞窗口为一个较小的值。
   - 在每个往返时间RTT（Round-Trip Time）内，拥塞窗口以指数增长
3. **拥塞避免**
   - 一旦拥塞窗口到达慢启动阈值，TCP进入拥塞避免阶段
   - 在拥塞避免阶段，拥塞窗口增长转为线性增长，有助于避免网络拥塞
4. **超时重传**
   - 如果发送方在超时时间内未收到确认，会认为数据包丢失并重传这些数据包
   - 发生超时重传时，拥塞窗口重新回到慢启动阶段，并将慢启动阈值减半
5. **快速重传和快速恢复**
   - 接收方始终发送它期望接收到的序列号，即ACK Number
   - 当发送方接收到3个重复的ACK后，立即开始重传丢失数据，不必等待计时器到期（即快速重传）
   - 此时拥塞窗口发生以下变化：
     - 慢启动阈值设置为当前拥塞窗口的1/2
     - 拥塞窗口大小设置为慢启动阈值大小
     - 拥塞窗口重新进入拥塞避免阶段（线性增长）
   - **快速恢复：**快速恢复是基于快速重传添加的算法，思想是“数据包守恒”，即老数据包离开网络后才能发送新的数据包
     - 当收到重复的3个ACK时，设置慢启动阈值为当前窗口1/2，设置拥塞窗口为慢启动阈值+3，重传丢失数据包
     - 发送方发送速率降低，每次仅发送一个数据包，且仅当收到重复ACK时，才将拥塞窗口+1
     - 只有当收到新的数据包的ACK时，将拥塞窗口设置为慢启动阈值，进入拥塞避免阶段

## Cookie和Session是什么？有什么区别

> `Cookie`和`Session`都是用于管理用户的状态和身份，`Cookie`通过在客户端记录信息确定用户身份，`Session`通过在服务器端记录信息确定身份

|   区别   |                            Cookie                            |                           Session                            |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 工作原理 | 由服务器发送并存储在客户端的小型文本文件，浏览器在请求头中携带Cookie，服务端解析Cookie得到客户端特有信息 | 当用户访问网站时，服务器会创建一个唯一的会话ID，并将此ID存储在Cookie中（如果启用了Cookie），或者将其作为URL的一部分进行传输。服务器使用会话ID来关联用户和他们的会话数据。 |
| 存储位置 |                            客户端                            |                            服务端                            |
| 数据容量 |                     容量较少，一般为几kb                     |            通常无固定配置，取决于服务器配置和资源            |
| 数据存储 |   Cookie通常用于存储少量的文本数据，如用户ID、偏好设置等。   | Session通常用于存储用户的敏感数据和状态信息，如用户登录信息。 |
|  安全性  | Cookie的数据存储在客户端，因此可以被用户查看和修改，所以不适合存储敏感信息 | 由于Session数据存储在服务器端，因此相对于Cookie来说更安全，用户无法直接访问或修改会话数据 |
| 生命周期 | Cookie可以设置过期时间，可以是会话级别（浏览器关闭后失效）或持久性（在指定的时间内有效） | Session数据可以在用户会话期间一直保持有效，通常在用户关闭浏览器或注销后会被销毁。管理员可以设置会话超时时间，以便在一段时间内没有活动时自动销毁会话。 |
| 传输方式 |                     在每次HTTP请求中携带                     |            Session ID通常通过Cookie或URL参数传递             |

# 【操作系统】

## 进程和线程的区别

|    区别    |                             进程                             |                             线程                             |
| :--------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|    定义    | 操作系统进行资源分配和调度的基本单位；是独立的执行单元，通常代表一个完整的程序实例 | 操作系统调度的最小单位；线程是进程的子任务，共享同一个进程的内存和资源 |
|  资源开销  | 每个进程拥有独立的内存空间，**创建和销毁开销较大；**<br />进程切换需要保存和恢复整个进程的状态，**上下文切换开销较高** | 线程共享相同的内存空间，**创建和销毁开销较小；**<br />线程间切换只需要保存和恢复少量的线程上下文，因此**上下文切换开销较小** |
| 通信与同步 | 进程间相互隔离，进程之间的通信可以通过管道、套接字、消息队列等特殊机制 | 线程共享相同的内存空间，同一进程下的线程可以直接访问共享数据，通信更方便 |
|   安全性   |            一个进程的崩溃不会影响其他进程的稳定性            |             一个线程的错误会影响整个进程的稳定性             |

## 进程调度算法

- **先来先服务调度算法（First-Come, First-Served，FCFS）**

  - 根据进程到达顺序进行调度，先到达的进程先执行
  - FCFS算法简单易实现，但可能导致饥饿现象，不适用响应时间要求高的系统

- **最短作业优先调度算法（Shortest Job First，SJF）**

  - 优先选择执行时间最短的进程
  - 实际系统中难以预测进程执行时间，通常采用近似算法：短作业剩余时间优先

- **最高响应比优先调度算法（Highest Response Ratio Next，HRRN）**

  - 计算每个进程的响应比（等待时间+执行时间/执行时间）
  - 优先选择响应比最高的进程执行，以平衡短作业和长作业的等待时间

- **时间片轮转调度算法（Round Robin，RR）**

  - 将CPU时间划分成固定长度的时间片，每个进程按顺序轮流执行一个时间片
  - 如果进程在时间片结束前没有执行完，则将被放入队列尾部等待下一个时间片
  - RR算法适用于多个进程共享CPU，并防止长时间占用CPU

- **多级反馈队列调度算法（Multilevel Feedback Queue，MLFQ）**

  - 将就绪队列分成多个级别，每个级别具有不同的时间片大小或优先级
  - 新进程被放入高优先级队列，老进程逐渐下降到低优先级队列
  - MLFQ算法根据进程行为自行调整优先级，适用于多种工作负载

- **最高优先级调度算法**

  为每个进程分配⼀个优先级，优先级较⾼的进程先执⾏。这可能导致低优先级进程⻓时间等待， 可能引发饥饿问题

## 进程间有哪些通信方式

- **管道**

  一种半双工的通信方式，数据只能单向流动而且只能在具有父子进程关系的进程间使用（实际上就是一个内存缓冲区，一个进程写入管道，另一个进程读取管道）

- **信号量**

  - 是一种用于控制多个进程对共享资源访问的机制
  - 常作为一种锁机制，进程可以使用信号量来进行同步和互斥，以避免资源冲突

- **消息队列**

  - 消息队列是消息的链表，存放于内核中并由消息队列标识符表示
  - 消息队列允许不相关的进程通过在队列中发送和接收消息来进行通信。
  - 进程可以通过消息队列进行异步通信，发送和接收消息的顺序不一定相同。

- **共享内存**

  - 共享内存允许多个进程共享同一块内存区域，这样它们可以直接读写内存中的数据。
  - 这是一种高效的通信方式，但需要谨慎处理同步和互斥问题。（往往与信号量配合使用）

- **`Socket`套接字**

  - 是⽀持TCP/IP 的⽹络通信的基本操作单元，主要⽤于在客户端和服务器之间 通过⽹络进⾏通信。

## 什么是死锁，如何避免死锁

**死锁**是指两个或多个进程在争夺系统资源时，由于互相等待对方释放资源而无法继续执行的状态

**死锁的四个条件：**

- 互斥
- 请求并保持
- 不可剥夺
- 循环等待

**破坏死锁的方法：**

- 破坏死锁的四个条件
  - 减少资源互斥性
  - 要求进程开始执行前获取所有资源，否则释放已有资源
  - 允许操作系统再某些情况抢占进程的资源
  - 进入资源的层级关系，要求进程按照一定顺序获取资源，从而避免形成循环等待
- 进入超时机制：等待资源超时的进程释放资源
- 资源分配策略：采用合理的资源分配策略
- 监控和检测：实现死锁检测和恢复机制，如检测到死锁发生，执行进程终止、资源回收等来解除死锁

## 什么是虚拟内存

虚拟内存是指在**每一个进程创建加载的过程中，会分配一个连续的虚拟地址空间**，它不是真实存在的，而是**通过映射与实际地址空间对应**，这样就可以使得每个进程看起来都拥有自己独立的连续地址空间，并允许程序访问比物理内存`RAM`更大的地址空间，每个程序都可以认为它拥有足够的内存来运行

**需要虚拟内存的原因：**

- **内存扩展**

  虚拟内存使每个程序都可以使用比实际可用内存更多的内存，从而允许运行更大的程序或处理更多的数据

- **内存隔离**

  虚拟内存提供了进程之间的内存隔离。每个进程都有自己的虚拟地址空间，因此一个进程无法直接访问另一个进程的内存

- **物理内存管理**

  虚拟内存允许操作系统动态地将数据和程序的部分加载到物理内存中，以满足当前正在运行的进程的需求。当物理内存不足时，操作系统可以将不常用的数据或内存暂时移到硬盘上，从而释放内存，以便其他进程使用。

- **页面交换**

  当物理内存不足时，操作系统可以将一部分数据从物理内存写入到硬盘的虚拟内存中，这个过程称为页面交换。当需要时，数据可以再次从虚拟内存中加载到物理内存中。这样可以保证系统可以继续运行，尽管物理内存有限

- **内存映射文件**

  虚拟内存还可以用于将文件映射到内存中，这使得文件的读取和写入可以像访问内存一样高效

## ⭐什么是内存分段和分页，作用是什么

|      |                           内存分段                           |                           内存分页                           |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 定义 | 将一个程序的内存空间分为不同的逻辑段（segments），每个段代表程序的一个功能模块或数据类型，如代码段、数据段、堆栈段等。每个段都有其大小和权限 | 把整个虚拟和物理内存空间分成固定大小的页（如4kb）。这样一个连续并且大小固定的内存空间称为页（page） |
| 作用 | 为不同类型的数据和代码提供独立的地址空间，以实现内存的隔离和保护。每个段可以具有不同的访问权限，从而增加内存的安全性 | 实现虚拟内存系统，允许进程访问比实际物理内存更大的地址空间。还支持页面置换，允许操作系统将不常用的页面置换到磁盘上以释放内存 |
| 优点 |   内存分段可以简化内存管理，提供更好的内存管理和内存保护。   | 内存分页提供了更灵活的内存管理方式，允许多个进程共享物理内存，而无需考虑内存分段的复杂性。它还实现了虚拟内存，使得程序能够访问比物理地址更大的地址空间 |

## 用户态和核心态

用户态（User Mode）和核心态（Kernel Mode），是操作系统中两种不同的执行模式，用于控制进程或程序对计算机硬件资源的访问权限和操作范围

- **用户态**

  在用户态下，进程或程序只能访问受限的资源和执行受限的指令集，不能直接访问操作系统的核心部分，也不能直接访问硬件资源。用户态下的CPU不允许独占，也就是说CPU能够被其他程序获取

- **核心态**

  核心态是操作系统的特权级别，允许进程或程序执行特权指令或访问操作系统的核心部分。在核心态下，进程可以直接访问硬件资源，执行系统调用，管理内存、文件系统等操作。

  处于内核态的CPU可以从一个程序切换到另外一个程序，并且占用CPU，不会发生抢占情况

## 解释页面置换算法，例如LRU、FIFO等

- **LRU（最近最少使用）算法**

  每次选择最长时间未被访问的页面置换出去。

  它维护一个页面访问历史记录，每次访问页面时，将该页面移到历史记录的开头

  - 优点：良好的反应程序的局部性原理
  - 缺点：需要维护一个历史访问记录

- **FIFO（先进先出）算法**

  按照页面进入物理内存的顺序来进行置换。最早进入内存的页面将最早被置换出去

  - 优点：实现简单
  - 缺点：无法考虑页面的访问频率，可能导致频繁使用的页面被置换出去

- **Clock（时钟）算法（最近未使用）**

  时钟算法基于环形链表或循环队列数据结构管理页面的访问情况，用于选择被置换的页面。

  当需要进行页面置换时，时钟算法从时钟指针位置开始遍历环形链表，如果当前页面访问位为0，则进行置换并设为1；否则继续遍历，若当前页面访问位为1，则置为0并继续遍历；循环遍历直到找到一个访问位为0的页面并选择其进行置换

- **LFU（最少使用）算法**

  将物理内存中访问次数最少的页面置换出去。它维护每个页面的访问次数，选择访问计数最低的页面进行置换

  - 优点：考虑页面的访问频率，可用于一些特定的应用场景
  - 缺点：导致一些页面在短时间内多次访问后被置换，不适用所有情况

- **OPT（最佳置换）算法**

  通过查看未来的页面访问顺序，选择最长时间不会被访问的页面来进行置换。理论最优，实践困难

  - 优点：最小化页面置换次数
  - 缺点：无法实际应用于操作系统中

## 解释进程同步和互斥，以及解决方法

**进程同步：**

进程同步是一种协调多个进程之间执行的机制，以确保他们按照期望的顺序或时间执行，以避免竞争条件和不确定性

**进程互斥：**

进程互斥是在某一时刻只允许一个进程访问某个共享资源。当一个进程正在使用共享资源时，其他进程不能同时访问该资源。

**解决方法：**

- **互斥锁**

  每个共享资源都关联一个互斥锁，只有获得锁的进程才能访问共享资源

- **临界区**

  将可能引发互斥问题的代码段称为临界区。每个进程在进入临界区前必须获取一个锁，退出临界区后释放锁。

- **条件变量**

  条件变量用于在进程之间传递信息，以便他们在特定条件下等待或唤醒，通常与互斥锁一起使用，以确保等待和唤醒的操作在正确的时机执行

- **信号量与PV操作**

  信号量是一种特殊的变量，它表示系统中某种资源的数量或状态。

  PV操作是一种对信号量进行减少或增加的操作（P减V增）

## 什么是中断和异常，它们有什么区别

中断和异常是两种不同的事件，它们都会导致CPU暂停当前的程序执行，转而去执行一个特定的处理程序

**区别：**

|              |                             中断                             |                             异常                             |
| :----------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   **性质**   |              来自外部设备或其他处理器的异步事件              |   CPU内部产生，通常是程序执行过程中出现的错误或不寻常情况    |
| **可否屏蔽** | 可以被屏蔽或禁止，CPU可以通过设置某些标志位寄存器来忽略或延迟响应中断信号 | 不可以被屏蔽或禁止，CPU必须立即响应异常信号，并进行相应的处理 |
| **处理方式** | 当发生中断时，处理器会停止当前正在执行的指令，保存当前上下文，并跳转到相应的中断处理程序来处理中断事件。中断处理程序会执行完后，控制返回到原来的程序。 | 当发生异常时，处理器会停止当前正在执行的指令，并跳转到相应的异常处理程序，该处理程序通常由操作系统或程序本身提供。异常处理程序的目的是恢复程序的正常执行或者终止程序的运行。 |
|   **举例**   |               时钟中断、键盘中断、硬盘I/O中断                |         除零异常、越界异常、非法指令异常、栈溢出异常         |

## 介绍一下几种典型的锁

- **互斥锁**

  在任何时刻，只有一个线程可以持有互斥锁，其他线程必须等待直到锁被释放。这确保了同一时间只有一个线程能够访问被保护资源

- **自旋锁**

  一种基于忙等待的锁，线程在尝试获取锁时会不断轮询直到锁被释放

- **读写锁**

  读共享，写排他

  允许多个线程同时读共享资源

  只允许一个线程在进行写操作时访问共享资源

  读读共存、写写互斥，读写互斥

- **悲观锁**

  认为多线程同时修改共享资源的概率比较高，所以访问共享资源时要上锁

- **乐观锁**

  先不管，修改了共享资源再说，如果出现同时修改情况，再放弃本次操作

  **CAS（V,A,B）操作：**

  - 目标值

    这是被CAS操作尝试修改的共享资源的当前值。在CAS操作开始前，线程会读取目标值的当前内容。

  - 期望值

    这是线程希望目标值当前拥有的值。CAS操作会比较目标值和期望值，只有在它们相等的情况下，CAS操作才会尝试修改目标值。如果目标值和期望值不匹配，CAS操作将失败。

  - 新值

    如果CAS操作成功（即目标值等于期望值），线程将使用新值来替换目标值。线程希望将目标值更新为的新值。

## 线程同步方式

- **互斥锁**

- **条件变量**

  条件变量⽤于线程间通信，允许⼀个线程等待某个条件满⾜，⽽其他线程可以发出信号通知等待线程。通常与互斥锁一起使用

- **读写锁**

- **信号量**

# 【数据库】
